\section{Die Programmiersprache C im Vergleich zu C++}
\label{sec:CVersusCPlusPlus}

In den nächsten Tagen werden wir Programme für eine Embedded-Plattform in C entwickeln.
Da C++ aus C entstand, sind viele Features von C++ nicht in C enthalten. Im Folgenden sollen die Hauptunterschiede verdeutlicht werden.
%
\begin{itemize}
	\item Keine OO-Konzepte (Vererbung, \dots)
    \item Strukturen (\lstinline{struct}) statt Klassen (\lstinline{class})
	\item Keine Templates
	\item Keine Referenzen, nur Zeiger und Werte
	\item Kein \lstinline{new} und \lstinline{delete}, sondern \lstinline{malloc()} und \lstinline{free()} (\lstinline|#include <stdlib.h>|)
	\item Je nach Sprachstandard müssen Variablen am Anfang der Funktion deklariert werden (Standard-Versionen bis einschießlich C99)
	\item Parameterlose Funktionen müssen \lstinline{void} als Parametertyp haben, leere Klammern (bspw. \lstinline{int foo();}) bedeuten, dass beliebige Argumente erlaubt sind.
	\item Keine Streams, stattdessen \lstinline{(f)printf} zur Ausgabe auf Konsole und in Dateien (\verb|#include <stdio.h>|)
	\item Kein \lstinline{bool}-Datentyp, stattdessen wird 0 als \lstinline{false} und alle anderen Zahlen als \lstinline{true} gewertet
	\item Keine Default-Argumente
	\item Keine \lstinline{std::string} Klasse, nur \lstinline{char}-Arrays, die mit dem Nullbyte (\lstinline{'\0'}) abgeschlossen werden.
	\item Keine Namespaces
\end{itemize}
%
Da einige dieser Punkte sehr entscheidend sind, werden wir auf diese im Detail eingehen.
Wichtig ist hierbei, dass alle im Folgenden vorgestellten Konzepte auch in C++ zur Verfügung stehen.
Die Header der C-Bibliothek sind alle auch in C++ verfügbar.
Möchte man bspw. \lstinline{malloc} nutzen, kann man dies in C++ über \lstinline|#include <stdlib.h>| oder über \lstinline{#include <cstdlib>} (Allgemeines Muster: vorangestelltes 'c' und fehlendes '.h').
Im zweiten Fall sind alle Funktionen im Namensraum \lstinline{std} eingebettet, man muss als \lstinline{std::malloc} nutzen.

\subsection{Kein OO-Konzept}
In C gibt es keine Klassen, weshalb die Programmierung in C eher Pascal statt C++ ähnelt.
Stattdessen gibt es Strukturen (\lstinline{struct}), die mehrere Variablen zu einem Datentyp zusammenfassen, was vergleichbar mit Records in Pascal oder -- allgemein -- mit Klassen ohne Methoden und ohne Vererbung ist.
%
Die Syntax dafür lautet
%
\lstinputlisting{problems/listings/cintro_structs.c}
%
Zum Beispiel
%
\lstinputlisting{problems/listings/cintro_structs_ex.c}
%
Die Sichtbarkeit aller Attribute ist automatisch \lstinline{public}.
%
Um den definierten \textbf{\lstinline|struct|} als Datentyp zu verwenden, muss man zusätzlich zum Namen das Schlüsselwort \lstinline{struct} angeben:
%
\lstinputlisting{problems/listings/cintro_structs_func.c}
%
Um den zusätzlichen Schreibaufwand zu vermeiden, wird in der Praxis oft ein \lstinline{typedef} auf den \lstinline{struct} definiert:
%
\lstinputlisting{problems/listings/cintro_structs_typedef.c}
%
Man kann die Deklaration eines \lstinline{struct} auch direkt in den \lstinline{typedef} einbauen:
%
\lstinputlisting{problems/listings/cintro_structs_short.c}

\subsection{Kein \lstinline{new} und \lstinline{delete}}

Anstelle von \lstinline{new} und \lstinline{delete} werden die Funktionen \lstinline{malloc} und \lstinline{free} verwendet, um Speicher auf dem Heap zu reservieren.
Diese sind im Header \filename{stdlib.h} deklariert.

\lstinputlisting{problems/listings/cintro_mallocfree.c}

\subsection{Ausgabe auf Konsole per \lstinline{printf}}

Um Daten auf der Konsole auszugeben, kann die Funktion \lstinline{printf} verwendet werden.
\lstinline{printf()} nimmt einen Format-String sowie eine beliebige Anzahl weiterer Argumente entgegen.
Der Format-String legt fest, wie die nachfolgenden Argumente ausgegeben werden.
Mittels \textbackslash n kann man einen Zeilenvorschub erzeugen. Um \lstinline{printf()} zu nutzen, muss der Header \filename{stdio.h} eingebunden werden.

\lstinputlisting{problems/listings/cintro_printf.c}

Weitere Möglichkeiten von \lstinline{printf()} findest du unter \url{http://www.cplusplus.com/reference/cstdio/printf/}.

\RKi{Zeigen, wie man einen String ganz leicht einkürzen kann und wie man durch Elimination des schließenden Nullbytes unabsichtlich den Speicher ausgeben kann.}

\subsection{Strings zusammenbauen}

Die Funktion \lstinline{sprintf} dient dazu, formatierte Strings zusammenzusetzen und ist \lstinline{printf} sehr ähnlich.

\RKi{Minimales Codebeispiel erzeugen (analog zur vorigen Aufgabem kleinen Puffer anlegen, dann bspw. den letzten String der vorigen Zeile hineinschreiben und ausgeben)}

\subsection{In Dateien schreiben}

Die Funktion \lstinline{fprintf} dient dazu, formatierte Strings zusammenzusetzen und in einer Datei abzulegen.

\RKi{Minimales Codebeispiel erzeugen (analog zur vorigen Aufgabem kleinen Puffer anlegen, dann bspw. den letzten String der vorigen Zeile hineinschreiben und ausgeben)}

\subsection{Zahlen formatiert ausgeben}
\label{sec:CFormatNumbers}
Schreibe ein C-Programm, welches alle geraden Zahlen von 0 bis 200 formatiert ausgibt.
Die Formatierung soll entsprechend dem Beispiel erfolgen:
%
\lstinputlisting{problems/listings/cintro_format.c}
%
Mache die Spaltenzahl und Spaltenbreite mithilfe von Variablen konfigurierbar, sodass es auch leicht möglich ist, 15 Spalten und/oder Zahlen bis \numprint{10 000} auszugeben.

\subsection{Arbeiten mit Bitoperationen}

\RKi{Hier alle Bitoperationen durchgehen und auch deren Effekte genau beschreiben. Auch auf logische Operatoren eingehen.}

\subsection{C++-Aufgaben nachprogrammieren \optional}

\optionaltextbox

Dies ist eine freie Aufgabe, in der du versuchst, Programme der vergangenen Tage in reinem C auszudrücken.
Der Schwierigkeitsgrad ist dabei sehr unterschiedlich!

\paragraph{Niedrigerer Schwierigkeitsgrad}
\begin{itemize}
\item
\textbf{Sternen- oder Buchstabenmuster} ausgeben (Blatt 1):
Diese Aufgabe ist sehr ähnlich zu \cref{sec:CFormatNumbers}.

\item
\textbf{Werte analysieren} und mit \textbf{Arrays} arbeiten (Blatt 2):
Abgesehen von der fehlenden Unterstützung für Referenzen sollten die Ergebnisse sich nicht unterscheiden.

\item
\textbf{Funktionszeiger} (Blatt 4):
Funktionszeiger in C arbeiten genauso wie Funktionszeiger in C++.
Du kannst dies testen, indem du die Programmlogik der vorigen Aufgabe in eine separate Funktion auslagerst, die neben der Spaltenbreite und Obergrenze der anzuzeigenden Zahlen zusätzlich einen Funktionszeiger-Parameter hat, der festlegt, was mit der jeweiligen Zahl vor der Ausgabe geschehen soll (bspw. verdoppeln, quadrieren).
\end{itemize}
\paragraph{Höherer Schwierigkeitsgrad}
\begin{itemize}
\item
\textbf{\lstinline|Vector|} (Blatt 1): C bietet keine Objektorientierung, aber du kannst eine \lstinline|struct| zur Datenhaltung anlegen und die Methoden der Klasse als Funktionen realisieren, deren Namen bspw. immer mit dem Präfix \lstinline|Vector_| beginnen und die als zusätzlichen Parameter einen Pointer auf eine \lstinline|Vector|-\lstinline|struct| erhalten.

\item 
\textbf{Verkettete Listen} (Blatt 2):
Die reinen Datenstrukturen für die Liste (\lstinline|List|) und für Listenelemente (\lstinline|ListItem|) lassen sich als \lstinline|struct| abbilden.
Methoden kannst du wieder auf Funktionen mit Namenskonvention und zusätzlichem Pointer-Parameter abbilden.

\item
\textbf{Generischer Vektor und Liste} (Blatt 4):
Auch wenn es in C keinen eingebauten Mechanismus wie die C++-Templates gibt, kannst du die \lstinline|Vector| und \lstinline|List|-Klasse generisch machen, indem du die Einträge des Vektors bzw. den \lstinline|content| der \lstinline|ListItems| als \lstinline|void*| deklarierst.

\item
\textbf{Eigene \lstinline|Array|-Klasse} (Blatt 4):
Ebenso wie bei generischem Vektor und Liste kannst du natürlich auch deine eigene \lstinline|Array|-Klasse schreiben.
\end{itemize}
