\section{\ExercisePrefixMemory Arrays und Zeigerarithmetik}
\label{sec:arrays}
Arrays sind zusammenhängende Speicherbereiche, die mehrere Variablen von gleichem Typ speichern können.
Arrays werden in C++ folgendermaßen angelegt: \lstinline{<Typ> <name>[<Größe>];}, zum Beispiel:

\cpppInputListing{02_memory/problems/listings/arrays_intro.cpp}

Falls das Array global ist, muss die Größe eine konstante Zahl sein, falls das Array in einer Funktion auf dem Stack angelegt wurde, kann die Größe auch durch eine Variable vorgegeben werden.
Auf jeden Fall bleibt diese während der Existenz des Arrays konstant und kann sich nach dem Anlegen nicht mehr ändern.

Ein Array kann direkt bei der Deklaration initialisiert werden:

\cpppInputListing{02_memory/problems/listings/arrays_example.cpp}

Man kann die Größe optional auch weglassen, in diesem Fall wird sie der Compiler anhand der angegebenen Elemente selbst ermitteln. Auf die einzelnen Elemente des Arrays kann man wie gewohnt über \textbf{arr[i]} zugreifen.

Arrays und Zeiger sind in C++ stark miteinander verwandt.
So ist der \textbf{Bezeichner} des Arrays gleichzeitig die \textbf{Adresse des ersten Elements}.
Somit kann man sowohl durch \textbf{*arr} (Dereferenzierung) als auch durch \textbf{arr[0]} auf das erste Element zugreifen.
Analog dazu kann man auch einen Zeiger auf das erste Element anlegen:

\cpppInputListing{02_memory/problems/listings/arrays_pointer.cpp}

Da die Elemente eines Arrays direkt hintereinander stehen, kann man den Zeiger inkrementieren, um zum  nächsten Element zu gelangen (sogenannte Pointerarithmetik).
Beispiel:

\cpppInputListing{02_memory/problems/listings/arrays_inc.cpp}

Somit kann man auf beliebige Elemente des Arrays über den Zeiger zugreifen:

\cpppInputListing{02_memory/problems/listings/arrays_pointer_inc.cpp}

Tatsächlich ist \textbf{*(p+i)} in \textbf{jeder Hinsicht äquivalent} zu \textbf{p[i]}.
Das bedeutet, dass man sowohl auf das i-te Element eines Arrays über \textbf{*(arr + i)} zugreifen kann als auch über \textbf{pointer[i]} auf das Element, auf welches der Zeiger \lstinline{pointer+i} zeigt!

In C++ findet keine automatische Bereichsprüfung bei Arrayzugriffen statt.
Du bist als Programmierer selbst dafür verantwortlich, dass niemals auf ein Element außerhalb der Array-Grenze zugegriffen wird.
Falls doch, kann es zu Programmabstürzen oder unerwünschten Effekten wie Buffer-Overflows kommen, die ein erhebliches Sicherheitsrisiko darstellen.
Bevorzuge deshalb Container-Klassen wie \lstinline{std::vector} (oder \lstinline{std::array} ab C++11) aus der Standardbibliothek anstelle von \glqq rohen\grqq{} Arrays.
Beachte außerdem, dass der \lstinline{delete[]}-Operator zwar das Array löscht, den Zeiger jedoch \textbf{nicht} auf \lstinline{NULL} setzt.
Dabei entsteht ein \emph{Dangling Pointer}, welcher dazu führen kann, dass später im Programm auf Speicherstellen zugegriffen wird, die nicht reserviert sind.
Setze deshalb Zeiger nach einem \lstinline{delete}/\lstinline{delete[]} sofort auf \lstinline{NULL}, um Speicherfehler zu vermeiden.

Um die Größe eines Arrays zu ermitteln, kannst du den \lstinline{sizeof()}-Operator benutzen.
Dieser gibt generell die Anzahl der Bytes an, die eine Variable verbraucht.
Da einzelne Array-Elemente größer als ein Byte sein können, muss die Gesamtgröße des Arrays durch die Größe eines Elements geteilt werden, um auf die Anzahl der Elemente zu kommen.

\cpppInputListing{02_memory/problems/listings/arrays_sizeof.cpp}

Beachte, dass \lstinline{sizeof()} \textbf{nicht} dazu verwendet werden kann, um die Größe des Arrays herauszufinden, auf die ein Zeiger zeigt.
In diesem Fall wird \lstinline{sizeof()} nämlich die \textbf{Größe des Zeigers} und nicht die Größe des Arrays liefern!

\cpppInputListing{02_memory/problems/listings/arrays_sizeof_pointer.cpp}

\subsection{Arrays anlegen}
Lege in der \lstinline{main}-Funktion ein \lstinline{int}-Array mit 10 Elementen an, und initialisiere es mit den Zahlen 1 bis 10.
Iteriere in einer Schleife über das Array und gib alle Elemente nacheinander aus.

\subsection{printElements implementieren}
In C und C++ kann man Arrays nicht direkt an Funktionen übergeben.
Stattdessen übergibt man einen Zeiger auf das erste Element des Arrays. Aufgrund der Äquivalenz von \textbf{*(p+i) } und \textbf{p[i]} kann man in der Funktion den Zeiger syntaktisch wie das Original-Array verwenden.

Schreibe eine Funktion, die einen \lstinline{const}-Zeiger auf das erste Element eines Arrays bekommt und alle Elemente ausgibt.
Da ein Array, wie bereits erwähnt, ein zusammenhängender Speicherbereich ist, hat die Funktion keine Möglichkeit, anhand des Zeigers herauszufinden, wie groß das Array ist. Denn das Ende des Arrays im Speicher ist unbekannt. Deshalb muss die Größe des Arrays durch einen weiteren Parameter übergeben werden\footnote{Statt \lstinline{unsigned int} wird oft der Standard-Typ \lstinline{size_t} genutzt (z.B. in \lstinline{std::vector}).}:

\cpppInputListing{02_memory/problems/listings/arrays_printelems.cpp}

\subsection{Offset-basierte Ausgabe}
Wie wir vorher gesehen haben, kann man mit Zeigern auch rechnen und diese nachträglich ändern.
Anstatt mit einem Index das Array zu durchlaufen, kann man stattdessen bei jeder Iteration den Zeiger selbst inkrementieren!

\cpppInputListing{02_memory/problems/listings/arrays_iterate.cpp}

Schreibe die Funktion aus der vorherigen Aufgabe so um, dass sie einen laufenden Zeiger anstatt eines Indexes verwendet.

\subsection{Iterator-basierte Ausgabe}
Ebenso kann man auch die Arraygröße auf eine andere Weise übergeben, indem man die Adresse des Elements nach dem letzten Element angibt.
Dadurch werden Schleifen der folgenden Form möglich.

\cpppInputListing{02_memory/problems/listings/arrays_iterate_end.cpp}

möglich.
Schreibe die Funktion aus der vorherigen Aufgabe entsprechend um.
Vergiss nicht, den Zeiger als \lstinline{const} zu definieren, da Elemente nur gelesen werden.
Du kannst hier \lstinline{const} doppelt verwenden, um auch sicherzustellen, dass der \lstinline{end}-Zeiger nicht verändert wird.

\subsection{Subarrays ausgeben}
Die obige Methode, über Elemente eines Arrays zu iterieren, mag dir zunächst etwas ungewöhnlich erscheinen.
Sie hat jedoch den Vorteil, dass man anstatt des ganzen Arrays auch kleinere zusammenhängende Teile davon an Funktionen übergeben kann, indem man Zeiger auf die entsprechenden Anfangs-und Endelemente setzt.
Beispiel:

\cpppInputListing{02_memory/problems/listings/arrays_print_with_index.cpp}

Experimentiere etwas mit dieser Übergabemethode in deiner eigenen Funktion!

\subsection{Arrays auf dem Heap}
Bisher haben wir das Array auf dem Stack angelegt.
Mit \textbf{new[]} kann man ein Array auf dem Heap erzeugen.
Dabei wird die Adresse des ersten Elements in einem Zeiger gespeichert.
Mittels \lstinline{delete[]} \textbf{muss} man den belegten Speicher nach Benutzung freigeben.
Beispiel:

\cpppInputListing{02_memory/problems/listings/arrays_heap.cpp}

Beachte die \textbf{[]} nach \lstinline{delete}.
Diese bewirken, dass das gesamte Array und nicht bloß das erste Element gelöscht wird.
Ein Anwendungsfall von dynamischen Arrays auf dem Heap sind Funktionen, die ein Array von vorher unbekannter Größe zurückgeben.

Schreibe nun eine Funktion, die beliebig viele Zahlen von der Konsole mittels \lstinline{std::cin} einliest.
Der Benutzer soll dabei zuvor gefragt werden, wie viele Zahlen er eingeben möchte.
Speichere die Zahlen in einem dynamisch angelegten Array ab und lasse die Funktion einen Zeiger darauf zurückgeben.
Hier ist ein Beispiel wie \lstinline{std::cin} zu verwenden ist:

\cpppInputListing{02_memory/problems/listings/arrays_cin_size.cpp}

Zusätzlich zum Zeiger muss die Funktion auch die Möglichkeit haben, ihrem Aufrufer die Größe des angelegten Arrays mitzuteilen.
Füge der Funktion deshalb einen weiteren Parameter hinzu, in dem entweder per Referenz oder per Zeiger eine Variable übergeben wird, um dort die Größe abzulegen\footnote{Du merkst sicherlich schon jetzt, dass es umständlich/fehleranfällig ist, wenn man die Größe eines Arrays separat speichern und übergeben muss.}.

Gib die eingelesenen Werte auf der Konsole aus.
Vergiss nicht, am Ende den Speicher freizugeben.
