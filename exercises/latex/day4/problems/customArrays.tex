\section{Eigene Arrays \optional}
\optionaltextbox
\label{sec:array}

Nachdem du bei unseren Übungen zu Arrays gesehen hast, dass es störend ist, wenn man die Größe eines Arrays immer getrennt zu den gespeicherten Daten verwalten muss, ist ein sinnvoller Schritt, eine eigene Array-Klasse zu implementieren, die Daten und Größe des Arrays zusammen speichert.

Eine möglicher Anwendungsfall sieht so aus:

\lstinputlisting{problems/listings/customArrays_example.cpp}

\emph{Hinweise}:
\begin{itemize}
\item
Überlege dir, welche Operatoren/Methoden das obige Code-Beispiel von Array verlangt.
Unter anderem musst du jeweils einen \lstinline{const} und einen nicht-\lstinline{const} \lstinline{operator[]} implementieren.

\item Du kannst auch Exceptions (z.B. \lstinline{std::out_of_range} aus \lstinline{<stdexcept>}) verwenden, um falsche Indices korrekt abzufangen.

\item Eine fortgeschrittene Übung ist es, Iteratoren oder \lstinline{operator+(unsigned int)} für \lstinline{Array} bereitszustellen, sodass du z.B. die Funktion \lstinline{std::copy} aus der Standardbibliothek verwenden kannst, um ein Array zu kopieren:

\lstinputlisting{problems/listings/customArrays_vector.cpp}

\item
Diese Idee ist natürlich nicht neu.
Seit C++11 gibt es eine Array-Implementation in der C++-Standardbibliothek (\lstinline{std::array}\footnote{\url{http://www.boost.org/doc/libs/1_55_0/doc/html/array.html}}).
Du findest die gleiche Klasse auch als \lstinline{boost::array} in Boost.
\end{itemize}
