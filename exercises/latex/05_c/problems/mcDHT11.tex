\section{\ExercisePrefixEmbeddedC DHT11 \optional}
Der DHT11 ist ein Temperatur- und Feuchtigkeitssensor, der mithilfe des Breadboards an den µController angeschlossen werden kann.
Als Anschlüsse hat der DHT11 4 Pins von denen im Rahmen des Praktikums  3 verwendet werden.
Zwei Pins werden für \lstinline|GND| und \lstinline|VCC| genutzt und ein Pin für die digitale Datenübertragung zwischen dem DHT11 und dem µController.
Abbildung \ref{fig:dht11Pins} zeigt die Pin-Belegung des DHT11.
Pin 1 wird mit \lstinline|VCC| verbunden und Pin 4 mit \lstinline|GND|. Pin 2 ist ein I/O Pin zur digitalen Datenübertragung.
In dieser Aufgabe ist es das Ziel die Temperatur- und Feuchtigkeitswerte des Sensors konitnuierlich auszulesen und diese auf dem Display darzustellen.
\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.2\textwidth]{./05_c/figures/DHT11.png}
	\caption{DHT11 Pinbelegung}
	\label{fig:dht11Pins}
\end{figure} 

\begin{enumerate}
\item 
Zunächst trenne den µController von der Stromzufuhr und stelle sicher, dass dieser ausgeschaltet ist.
Verbinde gemäß Abbildung \ref{fig:dht11Schematics} den DHT11 mit dem µController.
Der DHT11 wird, von links gezählt, an den dritten Pin des CN9 Steckers des µControllers angeschlossen.
Nutze als Untersützung Abbildung \ref{fig:cpppWiring}, die schematisch die GPIOs des µControllers darstellt.
Bevor du den µController wieder an deinen Computer anschließt, lasse deine Anordnung von einem Tutor überprüfen.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.35\textwidth]{./05_c/figures/DHT11-Schematics.pdf}
	\caption{Verkabelung des DHT11}
	\label{fig:dht11Schematics}
\end{figure} 
\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.7\textwidth]{./05_c/figures/cppp-wiring.pdf}
	\caption{Verkabelung des DHT11}
	\label{fig:cpppWiring}
\end{figure} 
\item 
In der Funktion \lstinline|readDHT11(uint8_t* humidity, uint8_t* temperature)| wird zunächst eine Präambel vom DHT11 an den µController gesendet.
Durch die Präambel wird die Verbindung zwischen dem Sensor und dem µController sichergestellt und der Sensor beginnt 40 Bits an den µController zu senden.
Abbildung \ref{fig:dht11Package} zeigt die Aufteilung der Bitgruppen.
Implementiere die fehlenden Stellen der Funktion \lstinline|readDHT11(uint8_t* humidity, uint8_t* temperature)|.
Nach der Präambel musst du zunächst über zwei Schleifen die 40 Bits durchiterieren und in einem Array mit 5 Einträgen je 8 Bits speichern.
Lese mit \lstinline|Gpio1pin_Get(GPIO1PIN_PF7)| den aktuellen Wert des digitalen Pins aus und entscheide entsprechend der folgenden Logik, ob es sich um eine 1 oder 0 handelt.
Ist der Pin länger als 30µs auf \lstinline|HIGH| gesetzt $t_{HIGH} > 30$µs, dann interpretiere dieses Signal als eine 1 und im umgekehrten Fall $t_{HIGH} < 30$µs als eine 0.
Nachdem alle 40 Bits empfangen wurden, bilde die Checksumme, und verlasse die Methode, sofern diese nicht stimmt.
Ist die Checksumme richtig, speichere die aktuelle Temperatur und Feuchtigkeit in den übergebenen Parametern ab.
\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.7\textwidth]{./05_c/figures/dht11Bits.pdf}
	\caption{40 Bit Datenstruktur eines DHT11 Pakets}
	\label{fig:dht11Package}
\end{figure} 
\hints{
	\item Bei der Abfrage des Pins mithilfe von \lstinline|Gpio1pin_Get(GPIO1PIN_PF7)|, kann es dazu kommen, dass fehlerhafte Signale dauerhaft auf \lstinline|HIGH| oder \lstinline|LOW| bleiben.
	Um diesen Fall zu filtern, verwende folgende Art der Abfrage.
}
\cpppInputListing{05_c/listings/dht11.c}

\item 
Nutze die Methoden writeTextln() und writeNumberOnDisplay() der Display-Library, um die Sensorenwerte auf dem Display auszugeben.

\hints{
	\item 
	Falls du die Methoden writeTextln() und writeNumberOnDisplay() noch nicht implementiert hast, kannst du die Musterlösungen mit dem Suffix \_s nutzen.
}

\end{enumerate}