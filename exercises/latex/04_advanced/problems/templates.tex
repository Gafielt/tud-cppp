% !TeX spellcheck = de_DE
\section{\ExercisePrefixAdvanced Generische Funktionen (Templates)}
\cpppSolutionName{templates}{templates}
\subsection{Templatefunktionen implementieren}
Implementiere die folgende Funktion, die das Maximum von zwei Variablen liefert:

\cpppInputListing{04_advanced/problems/listings/templates_max.hpp}

Durch die Verwendung von Templates soll die Funktion mit verschiedenen Datentypen funktionieren.
Teste deine Implementation.

In der Vorlesung haben wir gesehen, dass jede Verwendung von \lstinline{t1} und \lstinline{t2} in \lstinline{maximum} eine Schnittstelle induziert, die der Typ \lstinline{T} bereitstellen muss.
Das bedeutet, dass \lstinline{T} alle Konstruktoren, Methoden und Operatoren zur Verfügung stellen muss, die in \lstinline{maximum} genutzt werden.

Wie sieht diese Schnittstelle in diesem Fall aus?
Welche Gründe gibt es, den Rückgabewert der Funktion \lstinline{maximum} als konstante Referenz festzulegen?

\hints{
\item In den meisten Fällen kann anstelle von \lstinline{typename} auch \lstinline{class} in der Template-Deklaration verwendet werden.
    
\item
In der Regel muss die Definition von Template-Funktionen und -Methoden im Header erfolgen, damit der Compiler das auszufüllende Template \enquote{textuell} vorliegen hat.
Dies ist der sicherere Weg und immer dann notwendig, wenn man nicht weiß, welche Spezialisierungen des Templates in Zukunft benötigt werden (\bspw bei der Entwicklung von Bibliotheken wie der STL).

Alternativ kann man die Definition der Methoden einer Templateklasse auch in einer \filename{cpp}-Datei angeben.
In diesem Fall muss man dafür sorgen, dass die benötigten Spezialisierungen auch in der \filename{cpp}-Datei eingefordert werden (\bspw durch ein \lstinline|typedef|).
Weitere Spezialisierungen in anderen \filename{cpp}-Dateien sind dann aber nicht mehr möglich.
Diese Option ist eher in Sonderanwendungsfällen sinnvoll und hat den Vorteil, dass man die Implementierung weiterhin vom Header getrennt hält.
}

\subsection{Explizite Angabe der Typparameter}
Lege nun zwei Variablen vom Typ \lstinline{int} und \lstinline{short} an, und versuche, mittels \lstinline{maximum()} das Maximum zu bestimmen.
Der Compiler wird mit der Fehlermeldung \textbf{no matching function for call...} abbrechen, da er nicht weiß, ob \lstinline{int} oder \lstinline{short} der Template-Parameter sein soll.
Gib deshalb den Template-Parameter mittels \lstinline{maximum<int>()} beim Aufruf von \lstinline{maximum()} explizit an.
Die übergebenen Parameter werden dabei vom Compiler automatisch in den gewünschten Typ umgewandelt.

\subsection{Induzierte Schnittstelle implementieren}
Erstelle eine Klasse \lstinline{C}, die eine Zahl als Attribut beinhaltet. Implementiere einen passenden Konstruktor sowie einen Getter für diese Zahl. Nun wollen wir unsere Funktion  \lstinline{maximum()} verwenden, um zu entscheiden, welches von zwei \lstinline{C}-Objekten die größere Zahl beinhaltet.
Überlege dir, was zu tun ist, und implementiere es.

\hints{
	\item Die Klasse \lstinline{C} muss mindestens die durch \lstinline{maximum} induzierte Schnittstelle implementieren.
}
