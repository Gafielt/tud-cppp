\section{\ExercisePrefixAdvanced Funktionales Programmieren \experimental}
\label{sec:functional}
\experimentaltextbox

In dieser Aufgabe werden Funktionen aus der funktionalen Programmierung vorgestellt.
Diese sind \lstinline{map}, \lstinline{filter} und \lstinline{reduce}. \\

Der Ablauf ist wie folgt:
\begin{itemize}
    \item In Teilaufgabe \ref{sec:map-filter-reduce-intro} werden erst einmal die Funktionsweisen der zu implementierenden Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} vorgestellt.
	\item In Teilaufgabe \ref{sec:map-filter-reduce-basic-impl} wirst du diese Funktionen implementieren und Hilfsfunktionen, welche dann verwendet werden können, implementieren.
	\item In Teilaufgabe \ref{sec:functional_functor} wirst du deine Hilfsfunktionen als \emph{Funktoren} implementieren und \lstinline{map}, \lstinline{filter} und \lstinline{reduce} entsprechend anpassen.
	\item Daraufhin werden Templates eingebaut, damit Funktionen und Funktoren verwendet werden können. Dies wird in \ref{sec:functional_template} passieren.
	\item In \ref{sec:functional_method} werden außerdem noch Methodenzeiger vorgestellt.
\end{itemize}

\subsection{Erklärung \lstinline{map}, \lstinline{filter} und \lstinline{reduce}}\label{sec:map-filter-reduce-intro}

Arbeitet man auf iterierbaren Sequenzen, ist dies fast immer mit Schleifen über die Sequenz verbunden.
Die drei Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} vereinfachen uns hierbei die Arbeit.
Hierzu ein Beispiel.
Haben wir einen Vektor des Typs \lstinline{double} und wollen jedes Element quadrieren, endet dies meist in dem folgenden Programmcode:

\cpppInputListing{04_advanced/problems/listings/functional_intro_example.cpp}

\paragraph{map}
Die Idee von der Funktion \lstinline{map} ist es, genau dies zu vereinfachen.
Sie erhält folgende Parameter: 
\begin{itemize}
    \item Die Start- und Enditeratoren der zu modifizierenden Sequenz
    \item Einen Iterator, der auf eine Sequenz zeigt, in der die veränderten Elemente gespeichert werden sollen
    \item Einen Funktionszeiger, der auf eine Funktion zeigt, die für jedes Element der iterierbaren Sequenz aufgerufen werden soll
\end{itemize}

Ein Beispiel siehst du in folgendem Listing:

\cpppInputListing{04_advanced/problems/listings/functional_map_example.cpp}

\paragraph{filter}
\lstinline{filter} funktioniert analog, indem sie einen Funktionszeiger auf eine Funktion erhält, die einen Listenelementtyp erwartet und ein \lstinline{bool} zurück gibt.
Auf alle Elemente wird diese Funktion aufgerufen und alle Elemente, für die die Funktion \lstinline{true} zurückgibt, werden in die Ausgabesequenz kopiert. Der Rest wird entfernt. \\

\cpppInputListing{04_advanced/problems/listings/functional_filter_example.cpp}

\paragraph{reduce}
Und auch \lstinline{reduce} hat eine ähnliche Verwendung.
Es schrumpft eine Sequenz zu einem Element zusammen.
Hierbei wird der Ausgabeiterator gegen einen Startwert ausgetauscht.
Hier ein Beispiel, bei dem die Summe über die Elemente in \lstinline{numbers} gebildet wird.

\cpppInputListing{04_advanced/problems/listings/functional_reduce_example.cpp}

\subsection{Programmieren der Funktionen}
\label{sec:map-filter-reduce-basic-impl}

Du wirst nun diese drei Funktionen nachprogrammieren.
Hierbei geht es erstmal darum, ein funktionierendes Gerüst der Methoden zu erstellen, anstatt perfekt generische Algorithmen zu erhalten.
Darum wird sich im Laufe der Aufgabe gekümmert.

\subsubsection{\lstinline{map}}

Schreibe eine Funktion \lstinline{map} die folgende Signatur besitzt.

\cpppInputListing{04_advanced/problems/listings/functional_map_sig.cpp}

Hierbei ist der letzte Parameter der Funktionszeiger.
Die Klammern um \lstinline{*func} sind deshalb notwendig, damit die Sichtbarkeit sichergestellt ist und der Kompiler den übergebenen Parameter als Funktionszeiger einer Funktion mit Rückgabewert \lstinline{double} interpretiert und nicht als Funktion mit Rückgabewert \lstinline{double *}\footnote{Welche folgende Signatur hätte: \lstinline{double *(*func)(double d)}}.
Diese Funktion hat zusätzlich noch einen Double \lstinline{d} als Paramenter.

\subsubsection{\lstinline{filter}}

Die von dir zu schreibende Funktion \lstinline{filter} soll der folgenden Signatur folgen.

\cpppInputListing{04_advanced/problems/listings/functional_filter_sig.cpp}

\subsubsection{\lstinline{reduce}}

Erstelle eine Funktion \lstinline{reduce}, die der folgenden Signatur folgt.

\cpppInputListing{04_advanced/problems/listings/functional_reduce_sig.cpp}

Hierbei muss ein passender initialer Wert übergeben werden, der mit dem Rückgabewert und dem ersten Argument der übergebenen Funktion zusammenpasst.

\subsubsection{Passende Hilfsfunktionen implementieren}
Implementiere in dieser Aufgabe drei Hilfsfunktionen, die den Anforderungen der jeweiligen Signaturen der Funktionszeiger in den Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} folgen.
Du kannst dir dabei gerne eigene Funktionen ausdenken oder dich an die Funktionen in den Beispielen halten. 

Teste anschließend deine Implementation, indem du die Funktionen nur anhand ihres Namens übergibst.

\subsection{Funktoren}
\label{sec:functional_functor}
Es gibt außerdem noch die Möglichkeit, Funktionen in einem Funktionsobjekt (\emph{Funktor}) zu schachteln.
Dabei überlädt man den Operator \lstinline{operator()}, welcher eine bestimmte Funktion ausführt. 
Schaut man sich in unserem Beispiel die Funktion \lstinline{square} mit der Definition \lstinline{double square(double i);} an, würde der Funktor folgendermaßen aussehen:

\cpppInputListing{04_advanced/problems/listings/functional_functor_square.cpp}

Die Funktion \lstinline{map} würde wie folgt umgeschrieben werden müssen, um den Funktor zu akzeptieren:

\cpppInputListing{04_advanced/problems/listings/functional_functor_map.cpp}

Schreibe alle deine Hilfsfunktionen auch als Funktoren und füge eine neue Implementation für \lstinline{map}, \lstinline{filter} und \lstinline{reduce} hinzu, die mit den Funktoren kompatibel ist.
Stelle anschließend sicher, dass dein Programm noch funktioniert.

\subsection{Verwendung von Templates}
\label{sec:functional_template}
Die derzeitige Implementation funktioniert entweder mit Funktoren einer bestimmten Klasse oder mit Funktionszeigern, die einem bestimmten Typen angehören, der durch die Signatur der Funktion festgelegt ist.
Dies ist nicht immer das gewünschte Ergebnis.
Um das Problem zu lösen, kann man den Übergabetypen durch ein Template ersetzen.
Damit ist der Typ der Übergabe nicht mehr relevant und die Parameteranzahl und -typen sind nicht mehr festgelegt. So kann jede beliebige Funktion übergeben werden.
Innerhalb der Funktion muss nur darauf geachtet werden, dass dem Funktionszeiger/Funktor die richtige Variable übergeben wird.

Implementiere in deinen Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} einen weiteren Templatetypen, indem du die Liste der Templatetypen erweiterst zu 

\cpppInputListing{04_advanced/problems/listings/functional_template_typename.cpp}

Verwende diesen statt der bisherigen Signatur für die übergebene Funktion/den übergebenen Funktor.
Teste deine Implementation anschließend sowohl mit Funktoren, als auch mit Funktionen.

\subsection{Methodenzeiger}
\label{sec:functional_method}
Es gibt auch die Möglichkeit, Methoden\footnote{Hier ist eine einfache Erklärung zu dem Unterschied von Funktion und Methode zu finden \url{http://stackoverflow.com/a/155655}} via Zeiger auszuführen (sogenannte \textbf{Methodenzeiger}).
Hierzu muss man zusätzlich zu dem Funktionsnamen noch ein Objekt übergeben, das die Methode bereitstellt.

In unserem Beispiel von \lstinline{Square} fügen wir noch eine weitere Methode \lstinline{squareroot} hinzu, welche das Inverse der Quadrierung, die Wurzeloperation, ausführt.
Unsere Klasse Square verändert sich dementsprechend zu

\cpppInputListing{04_advanced/problems/listings/functional_method_square.cpp}

und unser \lstinline{map} zu 

\cpppInputListing{04_advanced/problems/listings/functional_method_map.cpp}

Deine Aufgabe ist es nun, eine neue Implementierung von \lstinline{map} hinzuzufügen, deinem für \lstinline{map} geschriebenen Funktor eine weitere Methode hinzuzufügen und anschließend deine Implementation mit allen implementierten Methoden zu testen.

\subsection*{Nachwort zu dieser Aufgabe}
Für produktive C++-Programme bietet die Standardbibliothek fertige Funktionen und Klassen, um die gerade erlernten Prinzipien dieser Aufgabe zu realisieren, z.B. \lstinline{std::function<...>}\footnote{\url{http://en.cppreference.com/w/cpp/utility/functional/function}} und \lstinline{std::bind()}\footnote{\url{http://en.cppreference.com/w/cpp/utility/functional/bind}}.
Diese können mit beliebiger Anzahl von Parametern umgehen und beinhalten viele weitere Features.
