\section{\ExercisePrefixAdvanced Generische Verkettete Liste (Templates)}
\label{sec:list}
\label{sec:genericLinkedList}
\cpppSolutionName{generic_linked_list}{generic\_linked\_list}
\subsection{}
Schreibe die Klassen \lstinline{List}, \lstinline{ListItem} und \lstinline{ListIterator} aus dem zweiten Praktikumstag so um, dass man den Typen der in der Liste gespeicherten Elemente über einen Template-Parameter angeben kann.

Dazu müssen einige Änderungen gemacht werden.
Zum einen sollte der Inhalt eines Elements beim Erstellen nicht als Wert sondern als \lstinline{const} Referenz übergeben werden.
Zum anderen sollten die Methoden zum Löschen von Elementen \lstinline{void} zurückgeben, und nicht mehr das jeweilige gelöschte Element. Der Grund dafür ist, dass in diesem Fall eine temporäre Kopie des Elements gemacht werden müsste, ohne dass es der Benutzer beeinflussen kann.
Je nach Elementtyp können solche Kopien problematisch und unerwünscht sein.

\hints{
	\item Arbeite die Klassen nacheinander ab, beginnend bei \lstinline{ListItem}.
	\item Stelle sicher, dass man eine Klasse fehlerfrei kompilieren kann, bevor du zur nächsten übergehst.
	\item Denke daran, dass du auch hier die Implementation in eigene \filename{*.tpp}-Dateien verschieben musst.
}

\subsection{}
Überlade den \lstinline{operator<<}, sodass Listen direkt über ein \lstinline{std::ostream} wie z.B. \lstinline{std::cout} ausgegeben werden können.

\subsection{}
Teste deine Implementierung.
Probiere auch Folgendes aus und beobachte die Ausgabe.

\cpppInputListing{04_advanced/problems/listings/genericLinkedList.cpp}

\hints{
\item
In der ersten Zeile ist absichtlich ein Leerzeichen zwischen den beiden schließenden spitzen Klammern.
Bis hin zu C++11 konnte der C++-Compiler nicht erkennen, ob es sich bei \lstinline{>>} um den Operator oder um geschachtelte Templates handelt.
Seit C++11 ist es nicht mehr nötig, ein Leerzeichen zwischen die beiden schließenden spitzen Klammern einzufügen.
}
