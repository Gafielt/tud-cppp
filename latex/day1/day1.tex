\input{../common_head.tex}

\newcommand{\exday}{1}

\cppSetTitle
\setcounter{section}{-1}

\begin{document}

\cppSetHeaderAndMakeTitle

\section*{Einführung}
Einführung in C++

Einzeilige Kommentare können durch \texttt{//}, mehrzeilige durch \texttt{/* ... */} eingeschlossen.

\hints{
	\item Bei Fragen und Problemen aktiv um Hilfe bitten
	\item Die Materialien zur Übung sind unter \url{https://github.com/Echtzeitsysteme/tud-cpp-exercises} zu finden
	% includes a Eclipse tutorial and a Git tutorial
	\item Die Materialien zur Vorlesung sind unter \url{https://github.com/Echtzeitsysteme/tud-cpp-lecture} zu finden
}

\section{Hello World}
Lege ein neues C++ Projekt an, indem du \textbf{File $\rightarrow$ New $\rightarrow$ C++ Project} im Eclipse Menü wählst und als Projekttyp \textbf{Empty Project} auswählst.
Füge eine neue Sourcecodedatei zum Projekt hinzu, indem du mit der rechten Maustaste auf das Projekt klickst und \textbf{New $\rightarrow$ Source File} auswählst.
Gib als Dateinamen \texttt{main.cpp} ein und bestätige mit \textbf{Finish}.
Füge anschließend folgendes Programm ein, kompiliere und führe es aus.
%[numbers=left, numbersep=0pt, xleftmargin=10pt]
\begin{lstlisting}
	#include <iostream>
	int main() {
		std::cout << "Hello World" << std::endl;
	}
\end{lstlisting}

Jedes vollständige C++ Programm muss \textbf{genau eine} Funktion mit Namen \texttt{main} und Rückgabetyp \texttt{int} außerhalb von Klassen im globalen Namensraum besitzen. Andernfalls wird der Linker mit der Fehlermeldung \emph{undefined reference to 'main'} abbrechen.
Dieser wird verwendet um dem Aufrufer (Betriebssystem, Shell, \dots) den Erfolg oder Misserfolg der Ausführung zu signalisieren.
Typischerweise wird im Erfolgsfall 0 zurückgegeben.

Die erste Zeile des obigen Programms bindet den Header der \texttt{iostream} Bibliothek ein, welche unter anderem Klassen und Funktionen zur Ein- und Ausgabe mit Hilfe von $<<$ (\emph{insertion operator}) und $>>$ (\emph{extraction operator}) anbietet.
Diese Bibliothek ist Teil der C++-Standardbibliothek, welche eine Sammlung an generischen Containern, Algorithmen und vielen häufig genutzten Funktionen ist.
Um auf die Elemente dieser Bibliothek zuzugreifen, muss man ihren \texttt{namespace} (in diesem Fall \texttt{std}) voranstellen, gefolgt von zwei Doppelpunkten und dem gewünschten Element (in diesem Fall \texttt{cout} und \texttt{endl}).
Um Überschneidungen mit eigenen Definitionen zu vermeiden, ist es üblich Bibliotheken in einem \texttt{namespace} zu kapseln, welcher analog zu \texttt{package} in Java funktioniert, jedoch nicht an Ordnerstrukturen gebunden ist.

In der dritten Zeile wird der String \texttt{"Hello World"} in \texttt{std::cout} eingefügt, gefolgt von \texttt{std::endl}, das einen Zeilenumbruch erzeugt und die Ausgabepuffer leert. Für weitere Informationen zur Kommandozeilenausgabe siehe \url{http://www.cplusplus.com/doc/tutorial/basic_io/} und \url{http://www.cplusplus.com/reference/iomanip/}.

\hints{
	\item Anders als in Java können Funktionen auch außerhalb von Klassen definiert und verwendet werden.
	\item Die \texttt{return} Anweisung darf in der \texttt{main} Funktion weggelassen werden.
	\item Sourcecodedateien tragen in der Regel die Endung \emph{.cpp}, Headerdateien \emph{.h} oder \emph{.hpp}.
}



\newpage
\section{C++ Grundlagen, Funktionen und Strukturierung}
Für diese Aufgabe kannst du entweder das vorherige Programm weiter entwickeln oder genauso wie vorher ein neues Projekt anlegen.

\subsection{Sterne}
Schreibe eine Funktion \texttt{printStars(int n)}, die \texttt{n}-mal ein * auf der Konsole ausgibt und mit einem Zeilenumbruch abschließt.
Ein Aufruf von \texttt{printStars(5)} sollte folgende Ausgabe generieren:
\begin{lstlisting}
*****
\end{lstlisting}

Platziere die Funktion \textbf{vor} der \texttt{main}, da sie sonst von dort aus nicht aufgerufen werden kann.
Benutze die erstellte Funktion \texttt{printStars(int n)}, um eine weitere Funktion zu schreiben, die eine Figur wie unten dargestellt ausgibt.
Verwende hierzu Schleifen.
\begin{lstlisting}
*****
****
***
**
*
**
***
****
*****
\end{lstlisting}

\hints{
	\item Was die Benennung von Funktionen, Variablen und Klassen angeht, bist du frei.
Für Klassen ist CamelCase wie in Java üblich. Bei Funktionen und Variablen wird zumeist entweder auch Camel Case oder Kleinschreibung mit Unterstrichen verwendet.
}

\subsection{Auslagern der Datei}
Erstelle eine neue Header-Datei \texttt{functions.hpp} und eine neue Sourcecode-Datei \texttt{functions.cpp}. Beachte hierbei, dass Eclipse automatisch Include-Guards erzeugt, die das mehrfache Einbinden desselben Headers verhindern:
\begin{lstlisting}
#ifndef FUNCTIONS_HPP_
#define FUNCTIONS_HPP_
// your header ...
#endif /* FUNCTIONS_HPP_ */
\end{lstlisting}
Binde danach \texttt{functions.hpp} in beide Sourcecode-Dateien ein indem du
\begin{lstlisting}
#include "functions.hpp"
\end{lstlisting}
verwendest.
Verschiebe deine beiden Funktionen nach \texttt{functions.cpp}.

Schreibe nun in \texttt{functions.hpp} \textbf{Funktionsprototypen} für die beiden Funktionen aus der vorherigen Aufgabe.
Funktionsprototypen dienen dazu, dem Compiler mitzuteilen, dass eine Funktion mit bestimmtem Namen, Parametern und Rückgabewert existiert.
Ein Prototyp ist im wesentlichen eine mit \textbf{;} abgeschlossene Signatur der Funktion ohne Funktionsrumpf.
Der Prototyp von \texttt{printStars(int n)} lautet \texttt{void printStars(int n);}

Fertig -- die Ausgabe des Programms sollte sich nicht verändert haben.

\hints{
	\item Denke daran, auch in \texttt{functions.cpp} \texttt{iostream} einzubinden, falls du dort Ein- und Ausgaben verwenden willst.
	\item Beachte, dass es zwei verschiedene Möglichkeiten gibt, eine Header-Datei einzubinden - per \texttt{\#include <Bibliotheksname>} sowie per \texttt{\#include "Dateiname"}. Bei der ersten Variante sucht der Compiler nur in den Include-Verzeichnissen der Compiler-Toolchain, während bei der zweiten Variante auch die Projektordner durchsucht werden. Somit eignet sich die erste Schreibweise für System-Header und die zweite für eigene, projektspezifische Header.
	\item Anstelle der Include-Guards kannst du auch die Präprozessordirektive \texttt{\#pragma once} verwenden. Dies wird von den meisten Compilern unterstützt.
}

\subsection{Eingabe}
Erweitere das Programm um eine Eingabeaufforderung zur Bestimmung der Breite der auszugebenden Figur.
Die Breite soll dabei eine im Programmcode vorgegebene Grenze nicht überschreiten dürfen.
Gib gegebenenfalls eine Fehlermeldung aus.
Verwende zum Einlesen \texttt{std::cin} und den \emph{extraction operator}:
\begin{lstlisting}
int zahl;
std::cin >> zahl;
\end{lstlisting}
Erstelle auch für diesen Aufgabenteil eine eigene Funktion und lagere diese nach \texttt{functions.cpp} aus.

\subsection{Fortlaufendes Alphabet}
Statt eines einzelnen Zeichens soll nun das fortlaufende Alphabet ausgegeben werden.
Sobald das Ende des Alphabets erreicht wurde, beginnt die Ausgabe erneut bei \textquotesingle a\textquotesingle.
Beispiel:
\begin{lstlisting}
abc
de
f
gh
ijk
\end{lstlisting}

Implementiere dazu eine Funktion \texttt{char nextChar()}.
Diese soll bei jedem Aufruf das nächste auszugebende Zeichen von Typ \texttt{char} zurückgeben, beginnend bei \textquotesingle a\textquotesingle.
Dazu muss sich \texttt{nextChar()} intern das aktuelle Zeichen merken.
Dies kann durch die Verwendung von statischen Variablen erreicht werden. Diese behalten ihren alten Wert beim Wiedereintritt in die Funktion.
Ein statische Variable \texttt{c} wird mittels
\begin{lstlisting}
static char c = 'a';
\end{lstlisting}
deklariert.
In diesem Fall wird \texttt{c} \textbf{einmalig zu Beginn des Programms} mit 'a' initialisiert und kann später beliebig verändert werden.

\subsection{Namensräume}
Sinnvollerweise werden Bibliotheken in einen eigenen Namensraum gekapselt, damit ihre Funktionen nicht zufällig mit selbstgeschriebenen Funktionen kollidieren.
Erweitere dazu das Programm, indem du im Header die Funktionsprototypen wie folgt in einen \texttt{namespace} setzt.
\begin{lstlisting}
namespace fun {
	// function prototypes ...
};	// semicolon!
\end{lstlisting}
Denke daran, dass du die Namen der Funktionen in der Sourcedatei noch anpassen musst, indem du vor jede Funktion den gewählten \texttt{namespace}-Namen gefolgt von zwei Doppelpunkten setzt. Genauso muss der Namensraum vor jedem Aufruf der Funktion gesetzt werden.
\begin{lstlisting}
void fun::print_star(int n) {
	// ...
}
\end{lstlisting}

Vergisst man den Namensraum in der Sourcedatei anzugeben, findet der Linker keine Implementation zu der im Header definierten Funktion.
Weiterhin stünde diese Funktion nicht mehr im Bezug zum Header und könnte nur noch lokal verwendet werden (\texttt{print\_star(int n)} und \texttt{fun::print\_star(int n)} sind unterschiedliche Funktionen!).

\newpage
\section{Klassen}
Ziel dieser Aufgabe ist es die vorherige Aufgabe objektorientiert zu lösen. Hierfür werden wir nun eine Klasse schreiben, die das aktuelle Zeichen als Attribut enthält und durch Methoden ausgelesen und inkrementiert werden kann.

Anstatt
In der vorherigen Übung haben wir den Modifier \textbf{static} verwendet, um eine Funktion zu erstellen, welche fortlaufende Zeichen generiert.
Diese Methode hat jedoch mehrere Nachteile, unter anderem kann man die Funktion nicht in mehreren Threads gleichzeitig nutzen (Ausnahme C++11).



\subsection{a}
Lege ein neues Projekt an und füge dem Projekt eine neue leere Klasse \texttt{CharGenerator} hinzu.
Obwohl Eclipse Klassenrümpfe automatisch generieren kann, wollen wir aus Übungsgründen die Klasse diesmal manuell erstellen.
Erzeuge dazu einen Header \texttt{CharGenerator.hpp} und eine Sourcecode-Datei \texttt{CharGenerator.cpp}.
Binde \texttt{CharGenerator.hpp} in \texttt{CharGenerator.cpp} und in \texttt{main.cpp} ein.

Erstelle nun den Klassenrumpf von \texttt{CharGenerator} in der Header-Datei. Die allgemeine Syntax lautet hierbei

\begin{lstlisting}
class MyClass {
}; // semicolon!
\end{lstlisting}

Genauso wie bei Funktionen wird auch bei Methoden von Klassen zwischen Deklaration und Implementierung unterschieden.
Die Struktur der Klasse mit allen Attributen und Methodenprototypen wird im Header beschrieben, während die Sourcecode-Datei nur Implementierungen enthält.
Da wir noch keine Methoden definiert haben, ist unsere Sourcecode-Datei entsprechend leer.

\subsection{b}
Füge Ihrer Klasse nun das \texttt{private} Attribut \texttt{char nextChar} hinzu, in dem das als nächstes auszugebende Zeichen gespeichert wird. Im Gegensatz zu Java  werden in C++ die Access-Modifier \texttt{public}/\texttt{private}/\texttt{protected} nicht bei jeder Methode einzeln sondern blockweise angegeben. Dazu wird der jeweilige Access-Modifier an die gewünschte Stelle in der Klassendeklaration geschrieben und mit einem Doppelpunkt abgeschlossen.  Alle darauffolgenden Deklarationen werden nun unter diesem Modifier erstellt. Beispiel:

\begin{lstlisting}
class Foo {
public:
	void iAmPublic(); // public method
	// more public members
protected:
	void iAmProtected(); // protected method
	// more protected members
private:
	void iAmPrivate(); // private method
	...
};
\end{lstlisting}

Füge das Attribut \texttt{nextChar} als \textbf{private} hinzu.

\subsection{c}
Noch wurde \texttt{nextChar} kein Wert zugewiesen.
Das wollen wir nun nachholen und einen Konstruktor für die Klasse \texttt{CharGenerator} erstellen, der \texttt{nextChar} auf einen Anfangswert setzt.
Der Konstruktor wird als eine Methode ohne Rückgabetyp deklariert, die den gleichen Namen wie die Klasse hat, und beliebige Parameter beinhalten kann, in unserem Fall zunächst
\begin{lstlisting}
CharGenerator();
\end{lstlisting}

Erstelle den Konstruktorprototypen im \texttt{public}-Bereich der Klasse und eine Implementierung in der Sourcecode-Datei. Damit der Compiler weiß, zu welcher Klasse eine Methode/Konstruktor gehört, muss man vor dem Methodennamen den Scope der Klasse angeben.

\begin{lstlisting}
CharGenerator::CharGenerator() {  // Konstruktor von CharGenerator.
	...
}
\end{lstlisting}

Um \texttt{nextChar} einen Wert zuzuweisen, werden wir eine sogenannte Initialisierungsliste verwenden.
Diese beschreibt, wie die Attribute einer Klasse initialisiert werden.
Dadurch wird garantiert, dass beim Eintritt in den Konstruktorrumpf alle Objektattribute bereits initialisiert sind und verwendet werden dürfen.

Die Initialisierungsliste wird durch einen Doppelpunkt zwischen der schließenden Klammer der Parameterliste und der geschweiften Klammer des Rumpfes eingeleitet, und bildet eine mit Komma separierte Liste von Attributennamen und ihren Initialisierungsargumenten in Klammern.

Die Reihenfolge der Initialisierungsliste sollte der Deklarationsreihenfolge entsprechen.
Konstanten \textbf{müssen} in der Initialisierungsliste zugewiesen werden.

Beispiel:

\begin{lstlisting}
CharGenerator::CharGenerator(): nextChar('a') {
}
\end{lstlisting}

Initialisiere nun \texttt{nextChar} mit 'a' wie beschrieben.

\subsection{d}
Schreibe nun eine \texttt{public} Methode \texttt{char generateNextChar()} die analog zur vorherigen Aufgabe das nächste auszugebende Zeichen zurückgibt.
Teile die Methode in Prototyp und Implementierung auf.
Vergiss auch hier nicht, den Scope der Klasse bei der Implementierung anzugeben:

\begin{lstlisting}
char CharGenerator::generateNextChar() {
	...
}
\end{lstlisting}

\subsection{e}
Teste deine Implementierung.
Lege in der \texttt{main}-Funktion ein \texttt{CharGenerator}-Objekt mittels \texttt{CharGenerator charGen;} an.
Ein \texttt{new} ist dabei nicht erforderlich (näheres dazu in der nächsten Vorlesung).

Rufe \texttt{generateNextChar()} einige Male auf und überprüfe das Ergebnis über die Konsole oder den Debugger.

\subsection{f}
Wir wollen nun angeben können, mit welchem Zeichen unser \texttt{CharGenerator} beginnen soll.
Erweitere dazu den Konstruktor um einen Parameter \texttt{char initialChar} und ändere die Initialisierung von \texttt{nextChar}, damit dieser mit dem übergebenen Parameter gestartet wird.

Damit man nicht immer das Startzeichen angeben muss, kann man sogenannte \emph{Default Parameter} angeben.
Weise hierzu den Parameter im Prototypen einfach einen Wert zu.
An der Implementierung muss nichts geändert werden.
\begin{lstlisting}
class CharGenerator {
public:
	CharGenerator(char initialChar = 'a');
	...
};
\end{lstlisting}

Nun ist die Angabe des Startzeichens optional und kann auf Wunsch weggelassen werden.
Bei der Definition eines Default-Parameters müssen für alle nachfolgenden Parameter ebenfalls Default-Werte angegeben werden, um Mehrdeutigkeiten beim Aufruf zu vermeiden.

Teste deine Implementierung sowohl mit als auch ohne Angabe des Startzeichens.
Um ein Startzeichen anzugeben, lege das Objekt wie folgt an:
\begin{lstlisting}
CharGenerator charGen('x');
\end{lstlisting}

\subsection{g}
Erstelle eine neue Klasse \texttt{PatternPrinter} und füge ein \texttt{CharGenerator}-Objekt \texttt{charGenerator} als privates Attribut hinzu.
Erstelle auch einen leeren, parameterlosen Konstruktor für \texttt{PatternPrinter}.

Ohne eine Initialisierungsliste wird \texttt{charGenerator} mit dem Default-Parameter initialisiert.
Um ein eigenes Startzeichen anzugeben, muss eine Initialisierungsliste erstellt und \texttt{charGenerator} mit dem entsprechenden Argument initialisiert werden.

\subsection{h}
Erstelle die Methoden \texttt{void printNChars(int n)}, \texttt{int readWidth()} und \texttt{void printPattern()}, die entsprechend \texttt{n} Zeichen auf die Konsole ausgeben, die Breite einlesen und unter Verwendungen aller Methoden das Muster aus der vorherigen Aufgabe auf der Konsole ausgeben.
\texttt{printNChars} sollte hierbei \texttt{charGenerator} benutzen, um das nächste Zeichen ermitteln.

Teste deine Implementierung, indem du ein \texttt{PatternPrinter}-Objekt anlegst und \texttt{printPattern()} darauf aufrufst.



\newpage
\section{Operatorüberladung}
In C++ besteht die Möglichkeit, Operatoren wie \textbf{+} (\texttt{operator+}), \textbf{*} (\texttt{operator*}),\dots zu überladen.
Man kann selber spezifizieren, was beim Verknüpfen von Objekten mit einem Operator geschehen soll, um zum Beispiel den Quellcode übersichtlicher zu gestalten.
Du hast bereits das Objekt \texttt{std::cout} der Klasse \texttt{ostream} kennengelernt, welche den $<<$-Operator überlädt, um Ausgaben von \texttt{std::string}, \texttt{int},\dots komfortabel zu tätigen.
In dieser Aufgabe wollen wir eine eigene Vektor-Klasse schreiben und einige Operatoren überladen.

Wir werden am Tag 4 auf dieser Aufgabe aufbauen und den Vektor um weitere Funktionen erweitern.
Wirf deine Lösung also bitte nicht direkt weg.
Falls du mit dieser Aufgabe bis dahin nicht fertig sein solltest, kannst du natürlich auf die Musterlösung zurückgreifen.

\subsection{Konstruktor}
Schreibe eine Klasse \texttt{Vector3} mit den Attributen \texttt{a}, \texttt{b} und \texttt{c} vom Typ \texttt{double}, die die einzelnen Komponenten eines 3-dimensionalen Vektors darstellen.
Die Klasse soll drei Konstruktoren besitzen, einen parameterlosen \textbf{Default-Konstruktor}, der den Vektor mit \textbf{0} initialisiert, einen \textbf{Konstruktor mit 3 Parametern}, der die einzelnen Vektor-Komponenten auf die gegebenen Werte setzt, und einen \textbf{Copy-Konstruktor}.

Der Copy-Konstruktor wird aufgerufen, wenn das Objekt kopiert werden soll, z.B. für eine Call-by-Value Parameterübergabe.
Er nimmt ein Objekt vom gleichen Typ wie die Klasse selbst (in unserem Fall \texttt{Vector3}) als Parameter und kopiert alle Attribute.
Die Übergabe sollte dabei per const Reference geschehen.
Näheres dazu in der Vorlesung\footnote{Erklärung: Würden wir \texttt{other} by-Value übergeben, müsste eine Kopie von \texttt{other} angelegt werden.
Dazu würde der Copy-Konstruktor aufgerufen, was zu einer unendlichen Rekursion führt, bis der Stack seine maximale Größe überschreitet und das Programm abstürzt.}.
Bis dahin übernimm einfach die folgende Syntax für den Prototypen:
\begin{lstlisting}
Vector3(const Vector3 &other);
\end{lstlisting}

Dadurch kannst du \texttt{other} wie ein gewöhnliches \texttt{Vector3}-Objekt verwenden, es jedoch nicht verändern.

Füge jedem Konstruktor eine Ausgabe auf der Konsole hinzu, um beim Programmlauf den Lebenszyklus der Objekte nachvollziehen zu können

\subsection{Destruktor}

Erstelle außerdem einen Destruktor.
Ein Destruktor ist eine Methode, die automatisch beim Löschen des Objektes aufgerufen wird. Die Syntax des Prototypen lautet
\begin{lstlisting}
~Vector3();
\end{lstlisting}

und die Implementierung entsprechend
\begin{lstlisting}
Vector3::~Vector3() {
	...
}
\end{lstlisting}

Füge dem Destruktor eine Ausgabe auf der Konsole hinzu, um beim Programmlauf den Lebenszyklus der Objekte nachvollziehen zu können

\subsection{Vektoraddition}
Überlade den Operator \textbf{+} der Klasse \texttt{Vector3}, der eine komponentenweise Vektoraddition durchführt.
Die Signatur lautet
\begin{lstlisting}
Vector3 operator+(Vector3 rhs);
\end{lstlisting}
Das \texttt{Vector3} links ist dabei der Rückgabetyp der Überladung, der Parameter rhs die rechte Seite (\glqq right-hand-side\grqq{}) des \textbf{+}-Operators.
Dadurch, dass du den Operator als Member der Klasse deklarierst, nimmt die aktuelle Instanz hierbei automatisch die linke Seite der Operation an.
Platziere den Prototyp im \texttt{public}-Bereich der \texttt{Vector3} Klasse.

Die Implementierung lautet dementsprechend:
\begin{lstlisting}
Vector3 Vector3::operator+(Vector3 rhs) {
	...
}
\end{lstlisting}

Du kannst nun innerhalb der Methode durch \texttt{a}, \texttt{b} und \texttt{c} auf eigene Attribute und über  \texttt{rhs.a}, \texttt{rhs.b} und \texttt{rhs.c} auf Attribute der rechten Seite zugreifen.

\subsection{Vektorsubtraktion und Skalarprodukt}%\\[0ex]
Überlade auf die gleiche Weise auch die Operatoren $-$ für eine komponentenweise Vektorsubtraktion sowie \textbf{*} für ein Skalarprodukt.
Der Rückgabetyp eines Skalarprodukts ist kein \texttt{Vector3} sondern ein Skalar (\texttt{double})!

Jetzt kannst du Vektoren durch \texttt{v1 + v2}, \texttt{v1 - v2} und \texttt{v1 * v2} addieren/subtrahieren und das Skalarprodukt bilden.

\subsection{Ausgabeoperator (\texttt{operator<<}}
Um die Korrektheit unserer Implementierung zu testen, brauchen wie eine Ausgabemöglichkeit eines \texttt{Vektor3}-Objektes, idealerweise mit der gewohnten \texttt{std::cout $<<$ ...} Syntax.
Dazu überladen wir den $<<$ Operator.

Diesmal müssen wir die Überladung \textbf{außerhalb} der \texttt{Vektor3}-Klasse definieren, weil auf unser \texttt{Vektor3}-Objekt nun auf der rechten Seite der Operation steht. Der Funktionsprototyp lautet
\begin{lstlisting}
std::ostream& operator<<(std::ostream &out, Vector3 rhs);
\end{lstlisting}

Als linke Seite wird hierbei ein \texttt{ostream}-Objekt (wie z.B. \texttt{std::cout}) erwartet.
Um Ausgabeketten \texttt{std::cout} $<<$ \dots $<<$ \dots zu ermöglichen, muss das Ausgabeobjekt auch zurückgegeben werden. Damit das \texttt{ostream}-Objekt nicht jedes Mal kopiert wird, wird es als Referenz \textbf{\&} durchgereicht.

Die Implementierung hat folgende Form:
\begin{lstlisting}
ostream& operator<<(ostream &out, Vector3 rhs)  {
	out << ... ;
	return out;
}
\end{lstlisting}

Fülle die Funktion aus und kompiliere das Projekt.
Denke daran, den \texttt{iostream} Header einzubinden.

\subsection{Komponenten-Getter}
Der Compiler wird mit der Fehlermeldung
\begin{verbatim}
error: 'double Vector3::a' is private within this context
\end{verbatim}
abbrechen.
Dies liegt daran, dass die Attribute \texttt{a}, \texttt{b} und \texttt{c} privat und nur innerhalb der Klasse sichtbar sind.
Erstelle deshalb Getter-Methoden für die einzelnen Vektorkomponenten und verwende diese in der Ausgabefunktion.
Wenn alles funktioniert hat, kannst du beliebige \texttt{Vector3}-Objekte ausgeben:
\begin{lstlisting}
cout << v << endl;
\end{lstlisting} 

\subsection{Testen}
Teste deine bisher definierten Methoden und Funktionen.
Probiere auch Kombinationen von verschiedenen Operatoren aus und beobachte das Ergebnis.
Schreibe auch eine einfache Funktion, die Vektoren als Parameter nimmt.
Wie du siehst, werden sehr viele \texttt{Vector3}-Objekte erstellt, kopiert und gelöscht.
Dies liegt daran, dass die Objekte immer per Call-By-Value übergeben und dabei kopiert werden.
Wie dies vermieden werden kann, sehen wir im nächsten Teil des Praktikums.



\newpage
\section{Aufzugssimulation}
In dieser Aufgabe soll ein Grundgerüst für den in der Vorlesung vorgestellten Aufzug-Simulator geschaffen werden.
%Folgendes Klassendiagramm veranschaulicht die Klassenstruktur.
%\includegraphics{figures/Aufzug.png} %TODO replace with header file

\textbf{Hinweis:}
In den folgenden Übungsblättern werden wir den Aufzugsimulator verbessern und erweitern.
Generell gilt, dass diese Aufgaben eher länger sind und das bisher Gelernte festigen sollen.
Falls du feststellst, dass dir im Moment die Zeit dafür fehlt, kannst du diese Aufgaben auch nach hinten verschieben und als ausführliche Klausurvorbereitung nutzen.

\subsection{Klasse Person}
Schreibe eine Klasse \texttt{Person}.
Diese soll ein Attribut \texttt{int destinationFloor} haben, welches das Zielstockwerk angibt.
Initialisiere das Attribut im Konstruktor und schreibe einen entsprechenden Getter.
Füge dem Konstruktor außerdem eine Ausgabe auf die Konsole hinzu, um später beim Programmlauf den Erzeugungsprozess besser nachvollziehen zu können.
Erstelle zudem einen Destruktor für \texttt{Person} sowie den Copy-Konstruktor.
Vergiss nicht, im Copy-Konstruktor \texttt{destinationFloor} des anderes Objekts zu übernehmen.
Erstelle auch hier eine Konsolenausgabe, um den Lebenszyklus darzustellen.

\subsection{Klasse Elevator}
Schreibe eine Klasse \texttt{Elevator} mit den Attributen \texttt{int currentFloor}, \texttt{double energyConsumed} sowie \texttt{std::vector<Person> containedPeople}.
Dabei soll \texttt{int currentFloor} die Nummer des aktuellen Stockwerks repräsentieren, \texttt{double energyConsumed} die verbrauchte Energie.
In \texttt{containedPeople} werden die sich aktuell im Aufzug befindlichen Menschen gespeichert.
Dafür benutzen wir die Klasse \texttt{std::vector} aus der Standardbibliothek.
Binde dazu den Header \texttt{vector} ein.
Der Container \texttt{std::vector} kapselt ein Array und stellt eine ähnliche Funktionalität wie Javas \texttt{Vector} Klasse bereit.
Der Typ in spitzen Klammern (\texttt{<Person>} in \texttt{std::vector<Person>}) ist ein Template-Parameter und besagt, dass in dem Container \texttt{Person}-Objekte gespeichert werden sollen.

Implementiere zunächst einen Konstruktor, der die Attribute von \texttt{Elevator} sinnvoll initialisiert.
Da \texttt{containedPeople} leer initialisiert wird, brauchst du dafür keinen expliziten Aufruf.

\begin{lstlisting}
    /** Creates an elevator located at floor 0 */
	Elevator::Elevator() :
	    currentFloor(0),
	    energyConsumed(0.0) {}
\end{lstlisting}

Schreibe Getter für \texttt{currentFloor} und \texttt{energyConsumed}.
Implementiere außerdem die Methoden
\begin{lstlisting}
	/** Returns number of people in Elevator */
	int getNumPeople();
	
	/** Returns i-th Person in Elevator */
	Person getPerson(int i);
\end{lstlisting}

Du kannst mit \texttt{containedPeople.size()} auf die Länge eines Vektors zugreifen und mittels \texttt{containedPeople.at(i)} auf das i-te Element. \\

Implementiere auch die Methode
\begin{lstlisting}
	/** Moves the elevator to given floor */
	void moveToFloor(int floor);
\end{lstlisting}

die den Aufzug zu einem bestimmten Stockwerk bewegt.
Passe die verbrauchte Energie sinnvoll an; addiere beispielsweise die Differenz zwischen dem aktuellen und dem Zielstockwerk hinzu.

Als letztes müssen wir die Methoden zum Ein- und Aussteigen implementieren:
\begin{lstlisting}
	/** Adds people to Elevator */
	void addPeople(std::vector<Person> people);

	/** Removes people which arrived at their destination */
	std::vector<Person> removeArrivedPeople();
\end{lstlisting}

Du kannst dabei \texttt{containedPeople.push\_back(Person)} nutzen, um eine einzelne Person zur Menge der Insassen hinzuzufügen.
Um die Leute aussteigen zu lassen, die an ihrem Zielstockwerk angekommen sind, erstelle in der Methode zwei temporäre \texttt{std::vector}-Container \texttt{stay} und \texttt{arrived}.
Iteriere nun über alle Leute im Aufzug und prüfe, ob das Zielstockwerk der Person mit dem aktuellen Stockwerk des Aufzugs übereinstimmt.
Wenn ja, lasse die Person aussteigen, indem du sie zu der \texttt{arrived}-Liste mittels \texttt{push\_back()} hinzufügst.
Andernfalls muss die Person im Aufzug verbleiben (\texttt{stay}-Liste).
Gib am Ende die arrived-Liste zurück, und ersetze \texttt{containedPeople} durch \texttt{stay}.

\subsection{Klasse Floor}
Schreibe die Klasse \texttt{Floor} mit dem Attribut \texttt{std::vector<Person> containedPeople}.
Implementiere die folgenden Methoden:

\begin{lstlisting}
	/** Returns number of people on this floor */
	int getNumPeople();
	
	/** Returns i-th Person on this floor */
	Person getPerson(int i);
	
	/** Adds a Person to this floor */
	void addWaitingPerson(Person h);
	
	/** Removes all persons from this floor and return them */
	std::vector<Person> removeAllPeople();
\end{lstlisting}


Nutze \texttt{containedPeople.clear()} um alle Elemente eines Vektors zu löschen.

\subsection{Klasse Building}
Schreibe eine Klasse \texttt{Building}.
Füge einen Aufzug \texttt{elevator} sowie \texttt{std::vector<Floor> floors} als private Attribute hinzu.
Der Konstruktor soll die Anzahl der Stockwerke als Parameter erhalten und die Liste der Stockwerke (\texttt{floors}) mit einer entsprechenden Anzahl Stockwerke füllen.
Implementiere dazu die folgenden Methoden:

\begin{lstlisting}
	/** Constructs a building with the given number of floors */
	Buidling(unsigned int floors);
	
	/** Returns number of floors */
	int getNumOfFloors();
	
	/** Returns a certain floor as reference*/
	Floor& getFloor(int floor);
	
	/** Returns the elevator of this building */
	Elevator& getElevator();
\end{lstlisting}


\subsection{asdf}
Um die Benutzung des Simulators von außen zu vereinfachen und lange Aufrufketten wie
\begin{lstlisting}
	b.getElevator().addPeople(b.getFloor(b.getElevator().getFloor()).removeAllPeople());
\end{lstlisting}

zu vermeiden (\emph{Law of Demeter}), werden wir \texttt{Building} einige weitere Methoden hinzufügen.
Der Simulator sollte nur mit Methoden der Klasse \texttt{Building} kommunizieren.
Implementiere hierfür folgende Komfortmethoden:

\begin{lstlisting}
	/**
	 * Lets people on current floor go into the elevator.
	 */
	void letPeopleIn();
	
	/** Removes people from elevator on current floor which arrived at their destination */
	std::vector<Person> removeArrivedPeople();
	
	/** Moves the building's elevator to given floor */
	void moveElevatorToFloor(int i);
	
	/** Adds a person to given floor */
	void addWaitingPerson(int floor, Person p);
\end{lstlisting}

\subsection{asasdf2}
Teste deine Implementierung.
Erstelle dazu zunächst ein Gebäude und füge einige Personen hinzu.

\begin{lstlisting}
	Building b(3);
	b.addWaitingPerson(0, Person(2)); // person in floor 0 wants to floor 2
	b.addWaitingPerson(1, Person(0)); // person in floor 1 wants to floor 0
	b.addWaitingPerson(2, Person(0)); // person in floor 2 wants to floor 0
\end{lstlisting}

Implementiere nun folgende Beförderungsstrategie.
Diese sehr einfache (und ineffiziente) Strategie fährt alle Stockwerke nacheinander ab, sammelt die Leute ein und befördert sie jeweils zu ihren Zielstockwerken.

\begin{algorithm}[H]
 \SetAlgoLined
 \For{Floor floor \textbf{in} Building}{
   Move \texttt{elevator} to Floor \texttt{floor};\\
   Let all people on \texttt{floor} into \texttt{elevator};\\
   
  \While{elevator has people} {
    Move Elevator to destination Floor of first Person in Elevator; \\
    Remove arrived people; \\
  }
 }
\end{algorithm}

Gib am Ende auch die verbrauchte Energie aus.
Schau dir die Ausgabe genau an und versuche nachzuvollziehen, warum Personen so oft kopiert werden.
Denke daran, dass diese bei einer Übergabe als Argument kopiert werden.



\end{document}
