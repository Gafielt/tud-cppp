\input{../common_head.tex}

\newcommand{\exday}{1}

\cppSetTitle
\setcounter{section}{-1}

\begin{document}

\cppSetHeaderAndMakeTitle

\section*{Einführung}
Einführung in C++

Einzeilige Kommentare können durch \texttt{//}, mehrzeilige durch \texttt{/* ... */} eingeschlossen.

\hints{
	\item Bei Fragen und Problemen aktiv um Hilfe bitten
	\item Die Materialien zur Übung sind unter \url{https://github.com/Echtzeitsysteme/tud-cpp-exercises} zu finden
	% includes a Eclipse tutorial and a Git tutorial
	\item Die Materialien zur Vorlesung sind unter \url{https://github.com/Echtzeitsysteme/tud-cpp-lecture} zu finden
}

\section{Hello World}
Lege ein neues C++ Projekt an, indem du \textbf{File $\rightarrow$ New $\rightarrow$ C++ Project} im Eclipse Menü wählst und als Projekttyp \textbf{Empty Project} auswählst.
Füge eine neue Sourcedatei zum Projekt hinzu, indem du mit der rechten Maustaste auf das Projekt klickst und \textbf{New $\rightarrow$ Source File} auswählst.
Gib als Dateinamen \texttt{main.cpp} ein und bestätige mit \textbf{Finish}.
Füge anschließend folgendes Programm ein, kompiliere und führe es aus.
%[numbers=left, numbersep=0pt, xleftmargin=10pt]
\begin{lstlisting}
	#include <iostream>
	int main() {
		std::cout << "Hello World" << std::endl;
	}
\end{lstlisting}

Jedes vollständige C++ Programm muss \textbf{genau eine} Funktion mit Namen \texttt{main} und Rückgabetyp \texttt{int} außerhalb von Klassen im globalen Namensraum besitzen. Andernfalls wird der Linker mit der Fehlermeldung \emph{undefined reference to 'main'} abbrechen.
Dieser wird verwendet um dem Aufrufer (Betriebssystem, Shell, \dots) den Erfolg oder Misserfolg der Ausführung zu signalisieren.
Typischerweise wird im Erfolgsfall 0 zurückgegeben.

Die erste Zeile des obigen Programms bindet den Header der \texttt{iostream} Bibliothek ein, welche unter anderem Klassen und Funktionen zur Ein- und Ausgabe mit Hilfe von $<<$ (\emph{insertion operator}) und $>>$ (\emph{extraction operator}) anbietet.
Diese Bibliothek ist Teil der C++-Standardbibliothek, welche eine Sammlung an generischen Containern, Algorithmen und vielen häufig genutzten Funktionen ist.
Um auf die Elemente dieser Bibliothek zuzugreifen, muss man ihren \texttt{namespace} (in diesem Fall \texttt{std}) voranstellen, gefolgt von zwei Doppelpunkten und dem gewünschten Element (in diesem Fall \texttt{cout} und \texttt{endl}).
Um Überschneidungen mit eigenen Definitionen zu vermeiden, ist es üblich Bibliotheken in einem \texttt{namespace} zu kapseln, welcher analog zu \texttt{package} in Java funktioniert, jedoch nicht an Ordnerstrukturen gebunden ist.

In der dritten Zeile wird der String \texttt{"Hello World"} in \texttt{std::cout} eingefügt, gefolgt von \texttt{std::endl}, das einen Zeilenumbruch erzeugt und die Ausgabepuffer leert. Für weitere Informationen zur Kommandozeilenausgabe siehe \url{http://www.cplusplus.com/doc/tutorial/basic_io/} und \url{http://www.cplusplus.com/reference/iomanip/}.

\hints{
	\item Anders als in Java können Funktionen auch außerhalb von Klassen definiert und verwendet werden.
	\item Die \texttt{return} Anweisung darf in der \texttt{main} Funktion weggelassen werden.
	\item Sourcedateien tragen in der Regel die Endung \emph{.cpp}, Headerdateien \emph{.h} oder \emph{.hpp}.
}



\newpage
\section{C++ Grundlagen, Funktionen und Strukturierung}
Für diese Aufgabe kannst du entweder das vorherige Programm weiter entwickeln oder genauso wie vorher ein neues Projekt anlegen.

\subsection{Sterne}
Schreibe eine Funktion \texttt{printStars(int n)}, die \texttt{n}-mal ein * auf der Konsole ausgibt und mit einem Zeilenumbruch abschließt.
Ein Aufruf von \texttt{printStars(5)} sollte folgende Ausgabe generieren:
\begin{lstlisting}
*****
\end{lstlisting}

Platziere die Funktion \textbf{vor} der \texttt{main}, da sie sonst von dort aus nicht aufgerufen werden kann.
Benutze die erstellte Funktion \texttt{printStars(int n)}, um eine weitere Funktion zu schreiben, die eine Figur wie unten dargestellt ausgibt.
Verwende hierzu Schleifen.
\begin{lstlisting}
*****
****
***
**
*
**
***
****
*****
\end{lstlisting}

\hints{
	\item Was die Benennung von Funktionen, Variablen und Klassen angeht, bist du frei.
Für Klassen ist CamelCase wie in Java üblich. Bei Funktionen und Variablen wird zumeist entweder auch Camel Case oder Kleinschreibung mit Unterstrichen verwendet.
}

\subsection{Auslagern der Datei}
Erstelle eine neue Header-Datei \texttt{functions.hpp} und eine neue Sourcedatei \texttt{functions.cpp}. Beachte hierbei, dass Eclipse automatisch Include-Guards erzeugt, die das mehrfache Einbinden desselben Headers verhindern:
\begin{lstlisting}
#ifndef FUNCTIONS_HPP_
#define FUNCTIONS_HPP_
// your header ...
#endif /* FUNCTIONS_HPP_ */
\end{lstlisting}
Binde danach \texttt{functions.hpp} in beide Sourcedateien ein indem du
\begin{lstlisting}
#include "functions.hpp"
\end{lstlisting}
verwendest.
Verschiebe deine beiden Funktionen nach \texttt{functions.cpp}.

Schreibe nun in \texttt{functions.hpp} \textbf{Funktionsprototypen} für die beiden Funktionen aus der vorherigen Aufgabe.
Funktionsprototypen dienen dazu, dem Compiler mitzuteilen, dass eine Funktion mit bestimmtem Namen, Parametern und Rückgabewert existiert.
Ein Prototyp ist im wesentlichen eine mit \textbf{;} abgeschlossene Signatur der Funktion ohne Funktionsrumpf.
Der Prototyp von \texttt{printStars(int n)} lautet \texttt{void printStars(int n);}

Fertig -- die Ausgabe des Programms sollte sich nicht verändert haben.

\hints{
	\item Denke daran, auch in \texttt{functions.cpp} \texttt{iostream} einzubinden, falls du dort Ein- und Ausgaben verwenden willst.
	\item Beachte, dass es zwei verschiedene Möglichkeiten gibt, eine Header-Datei einzubinden - per \texttt{\#include <Bibliotheksname>} sowie per \texttt{\#include "Dateiname"}. Bei der ersten Variante sucht der Compiler nur in den Include-Verzeichnissen der Compiler-Toolchain, während bei der zweiten Variante auch die Projektordner durchsucht werden. Somit eignet sich die erste Schreibweise für System-Header und die zweite für eigene, projektspezifische Header.
	\item Anstelle der Include-Guards kannst du auch die Präprozessordirektive \texttt{\#pragma once} verwenden. Dies wird von den meisten Compilern unterstützt.
}

\subsection{Eingabe}
Erweitere das Programm um eine Eingabeaufforderung zur Bestimmung der Breite der auszugebenden Figur.
Die Breite soll dabei eine im Programmcode vorgegebene Grenze nicht überschreiten dürfen.
Gib gegebenenfalls eine Fehlermeldung aus.
Verwende zum Einlesen \texttt{std::cin} und den \emph{extraction operator}:
\begin{lstlisting}
int zahl;
std::cin >> zahl;
\end{lstlisting}
Erstelle auch für diesen Aufgabenteil eine eigene Funktion und lagere diese nach \texttt{functions.cpp} aus.

\subsection{Fortlaufendes Alphabet}
Statt eines einzelnen Zeichens soll nun das fortlaufende Alphabet ausgegeben werden.
Sobald das Ende des Alphabets erreicht wurde, beginnt die Ausgabe erneut bei \emph{a}.
Beispiel:
\begin{lstlisting}
abc
de
f
gh
ijk
\end{lstlisting}

Implementiere dazu eine Funktion \texttt{char nextChar()}.
Diese soll bei jedem Aufruf das nächste auszugebende Zeichen von Typ \texttt{char} zurückgeben, beginnend bei \emph{a}.
Dazu muss sich \texttt{nextChar()} intern das aktuelle Zeichen merken.
Dies kann durch die Verwendung von statischen Variablen erreicht werden. Diese behalten ihren alten Wert beim Wiedereintritt in die Funktion.
Ein statische Variable \texttt{c} wird mittels
\begin{lstlisting}
static char c = 'a';
\end{lstlisting}
deklariert.
In diesem Fall wird \texttt{c} \textbf{einmalig zu Beginn des Programms} mit \emph{a} initialisiert und kann später beliebig verändert werden.

\subsection{Namensräume}
Sinnvollerweise werden Bibliotheken in einen eigenen Namensraum gekapselt, damit ihre Funktionen nicht zufällig mit selbstgeschriebenen Funktionen kollidieren.
Erweitere dazu das Programm, indem du im Header die Funktionsprototypen wie folgt in einen \texttt{namespace} setzt.
\begin{lstlisting}
namespace fun {
	// function prototypes ...
};	// semicolon!
\end{lstlisting}
Denke daran, dass du die Namen der Funktionen in der Sourcedatei noch anpassen musst, indem du vor jede Funktion den gewählten \texttt{namespace}-Namen gefolgt von zwei Doppelpunkten setzt. Genauso muss der Namensraum vor jedem Aufruf der Funktion gesetzt werden.
\begin{lstlisting}
void fun::print_star(int n) {
	// ...
}
\end{lstlisting}

Vergisst man den Namensraum in der Sourcedatei anzugeben, findet der Linker keine Implementation zu der im Header definierten Funktion.
Weiterhin stünde diese Funktion nicht mehr im Bezug zum Header und könnte nur noch lokal verwendet werden (\texttt{print\_star(int n)} und \texttt{fun::print\_star(int n)} sind unterschiedliche Funktionen!).

\newpage
\section{Klassen}
Ziel dieser Aufgabe ist es die vorherige Aufgabe objektorientiert zu lösen. Hierfür werden wir nun eine Klasse schreiben, die das aktuelle Zeichen als Attribut enthält und durch Methoden ausgelesen und inkrementiert werden kann.

\subsection{Definition}
Eine Klasse wird üblicherweise analog zu der vorherigen Aufgabe in Deklaration (Headerdatei) und Implementation (Sourcedatei) aufgeteilt.
Die Struktur der Klasse mit allen Attributen und Funktionsprototypen wird im Header beschrieben, während die Sourcedatei nur die Implementation der Funktionen und Initialisierungen statischer Variablen enthält.
Standardmäßig sind alle Elemente einer Klasse privat.
Im Gegensatz zu Java werden in C++ die Access-Modifier \texttt{public}/\texttt{private}/\texttt{protected} nicht bei jedem Element einzeln sondern blockweise angegeben.
\begin{lstlisting}
class ClassName {
public:
	// public members ...
private:
	// private members ...
};	// semicolon!
\end{lstlisting}

Erzeuge einen Header \texttt{CharGenerator.hpp} und erstelle den Klassenrumpf der \texttt{CharGenerator} Klasse.
Füge der Klasse das \texttt{private} Attribut \texttt{char nextChar} hinzu, in dem das als nächstes auszugebende Zeichen gespeichert wird und einen \texttt{public} Konstruktorprototypen \texttt{CharGenerator()}, der \texttt{nextChar} auf \emph{a} initialiseren soll.
Füge noch eine \texttt{public} Funktionsprototypen \texttt{char generateNextChar()} hinzu, welche das nächste auszugebende Zeichen zurückgeben soll.


\hints{
	\item Ein Konstruktor wird als eine Funktion ohne Rückgabetyp deklariert, die den gleichen Namen wie die Klasse hat, und beliebige Parameter beinhalten kann.
}

\subsection{Implementation}
Wie bei der Verwendung von \texttt{namespace} muss der Scope der Klasse (der Klassenname) in der Sourcedatei vor jeder Elementbezeichnung (Konstruktor, Funktion, \dots) durch zwei Doppelpunkte getrennt angegeben werden.

\begin{lstlisting}
void ClassName::functionName() {
	// function implementation ...
}
\end{lstlisting}

Um Attribute zu initialisieren wird üblicherweise eine sogenannte Initialisierungsliste im Konstruktor verwendet, da diese vor dem Eintritt in den Konstruktorrumpf aufgerufen wird.
Die Initialisierungsliste wird durch einen Doppelpunkt zwischen der schließenden Klammer der Parameterliste und der geschweiften Klammer des Rumpfes eingeleitet, und bildet eine mit Komma separierte Liste von Attributnamen und ihren Initialisierungsargumenten in Klammern.

\begin{lstlisting}
ClassName::ClassName():
	// initializer list:
	attributeOne(initialValueOne),
	attributeTwo(initialValueTwo)
{
	// constructor body
}
\end{lstlisting}

Erzeuge eine Sourcedatei \texttt{CharGenerator.cpp} für die Implementation der Klasse und binde die \texttt{CharGenerator.hpp} ein.
Implementiere den Konstruktor, indem du \texttt{nextChar} mit \emph{a} in der Initialisierungsliste initialisierst.
Implementiere zudem \texttt{generateNextChar()}, indem du \texttt{nextChar} zurückgibst.

\hints{
	\item Die Reihenfolge der Initialisierungsliste sollte der Deklarationsreihenfolge entsprechen.
	\item Konstanten \textbf{müssen} in der Initialisierungsliste zugewiesen werden, damit diese zur Laufzeit bekannt sind.
}

\subsection{Instanziierung}
Erzeuge wie aus den vorherigen Aufgaben bekannt eine \texttt{main.cpp} mit einer \texttt{main()} Funktion in der du ein \texttt{CharGenerator}-Objekt erzeugst und \texttt{generateNextChar()} mehrfach aufrufst und ausgibst.
\begin{lstlisting}
CharGenerator charGen;
char next = charGen.generateNextChar();
std::cout << next << std::endl;
\end{lstlisting}
Überprüfe das Ergebnis über die Konsole oder den Debugger.

\hints{
	\item Um ein Objekt zu erzeugen, muss in C++ kein \texttt{new} verwendet werden (siehe dazu nächste Vorlesung).
}

\subsection{Default-Parameter}
Damit man nicht immer das Startzeichen angeben muss, kann man sogenannte Default-Parameter angeben, der beim Aufruf weggelassen werden kann.
Hierzu wird dem Parameter im Prototypen (im Header) ein Wert zugewiesen ohne die Implementation zu ändern.
\begin{lstlisting}
class CharGenerator {
public:
	CharGenerator(char initialChar = 'a');
	//...
};
\end{lstlisting}

Wir wollen nun angeben können, mit welchem Zeichen unser \texttt{CharGenerator} beginnen soll.
Erweitere dazu den Konstruktor um einen Parameter \texttt{char initialChar}, welcher defaultmäßig \emph{a} ist und ändere die Initialisierung von \texttt{nextChar}, damit dieser mit dem übergebenen Parameter gestartet wird.

Teste deine Implementierung sowohl mit als auch ohne Angabe des Startzeichens.
Um ein Startzeichen anzugeben, lege das Objekt wie folgt an:
\begin{lstlisting}
CharGenerator charGen('x');
\end{lstlisting}

\hints{
	\item Bei der Definition eines Default-Parameters müssen für alle nachfolgenden Parameter ebenfalls Default-Werte angegeben werden, um Mehrdeutigkeiten beim Aufruf zu vermeiden.
}

\subsection{PatternPrinter}
Implementiere folgende Klasse.
\begin{lstlisting}
class PatternPrinter {
private:
	CharGenerator charGen;
public:
	PatternPrinter();
	void printNChars(int n);	// print n characters to the console
	int readWidth();				// read width (user input)
	void printPattern();			// print pattern using CharGenerator methods
};
\end{lstlisting}

Teste deine Implementierung, indem du ein \texttt{PatternPrinter}-Objekt anlegst und \texttt{printPattern()} darauf aufrufst.

\hints{
	\item Ohne eine Initialisierungsliste wird \texttt{charGenerator} mit dem Default-Parameter initialisiert.
	Um ein eigenes Startzeichen anzugeben, muss eine Initialisierungsliste erstellt und \texttt{charGenerator} mit dem entsprechenden Argument initialisiert werden.
}



\newpage
\section{Operatorüberladung}
In C++ besteht die Möglichkeit, Operatoren wie \textbf{+} (\texttt{operator+}), \textbf{*} (\texttt{operator*}),\dots zu überladen.
Man kann selber spezifizieren, was beim Verknüpfen von Objekten mit einem Operator geschehen soll, um zum Beispiel den Quellcode übersichtlicher zu gestalten.
Du hast bereits das Objekt \texttt{std::cout} der Klasse \texttt{ostream} kennengelernt, welche den $<<$-Operator überlädt, um Ausgaben von \texttt{std::string}, \texttt{int},\dots komfortabel zu tätigen.
In dieser Aufgabe wollen wir eine eigene Vektor-Klasse schreiben und einige Operatoren überladen.

\hints{
	\item Wir werden am Tag 4 auf dieser Aufgabe aufbauen und den Vektor um weitere Funktionen erweitern.
	Falls du mit dieser Aufgabe bis dahin nicht fertig sein solltest, kannst du natürlich auf die Musterlösung zurückgreifen.
}

\subsection{Konstruktor und Destruktor}
Implementiere folgende Klasse.
Füge jedem Konstruktor und Destruktor eine Ausgabe auf der Konsole hinzu, um beim Programmlauf den Lebenszyklus der Objekte nachvollziehen zu können.
\begin{lstlisting}
class Vector3 {
public:
	Vector3();											// initialize vector with zero
	Vector3(double a, double b, double c);		// initialize vector with a, b, c
	Vector3(const Vector3& other);				// copy a vector
	~Vector3();											// destroy a vector
private:
	double a, b, c;									// vector components
};
\end{lstlisting}

Der Copy-Konstruktor wird aufgerufen, wenn das Objekt kopiert werden soll, z.B. für eine Call-by-Value Parameterübergabe.
Jeder Copy-Konstruktor benötigt eine Referenz auf ein Objekt vom gleichen Typ wie die Klasse selbst als Parameter. 
Sinnvollerweise wird noch \texttt{const} vor oder nach der Typbezeichnung eingefügt (aber vor \texttt{\&}), da typischerweise das Ursprungsobjekt nicht verändert wird.

Der Destruktor wird aufgerufen, sobald die Lebenszeit eines Objekts endet. Er wird verwendet, um Ressourcen die das Objekt besitzt freizugeben.
Die Syntax des Prototypen lautet
\begin{lstlisting}
~ClassName();
\end{lstlisting}
und die Implementation entsprechend
\begin{lstlisting}
ClassName::~ClassName() {/* destructor implementation ... */}
\end{lstlisting}

\hints{
	\item Es dürfen eine beliebige Anzahl an Konstruktoren mit verschiedenen Parametersätzen existieren.
	\item Der Compiler wird automatisch einen \texttt{public} Destruktor und \texttt{public} Copy-Konstruktor erzeugen, falls sie nicht definiert wurden. Ebenso wird ein \texttt{public} Defaultkonstruktor (keine Argumente) automatisch vom Compiler generiert, falls überhaupt keine Konstruktoren definiert wurden.
	\item Würden wir beim Copy-Konstruktor \texttt{other} by-Value übergeben, müsste eine Kopie von \texttt{other} angelegt werden.
	Dazu würde der Copy-Konstruktor aufgerufen, was zu einer unendlichen Rekursion führt, bis der Stack seine maximale Größe überschreitet und das Programm abstürzt.
}

\subsection{Vektoraddition, -subtraktion und Skalarprodukt}
Erweitere die Klasse um folgende \texttt{public} Funktionen, um Vektoren durch \texttt{v1 + v2}, \texttt{v1 - v2} und \texttt{v1 * v2} addieren/subtrahieren und das Skalarprodukt bilden zu können, indem die Operatoren +, - und * überladen werden.

\begin{lstlisting}
Vector3 operator+(Vector3 rhs);		// add two vectors component-by-component
Vector3 operator-(Vector3 rhs);		// subtract two vectors component-by-component
double operator*(Vector3 rhs);		// determine the dot product of two vectors
\end{lstlisting}

Innerhalb der Methode kannst du durch \texttt{a}, \texttt{b} und \texttt{c} auf eigene Attribute und über  \texttt{rhs.a}, \texttt{rhs.b} und \texttt{rhs.c} auf Attribute der rechten Seite zugreifen. Denke daran, bei der Implementation den Klassen den Scope der Klasse in der Sourcedatei vor jeder Elementbezeichnung durch zwei Doppelpunkte getrennt anzugeben.

\begin{lstlisting}
Vector3 Vector3::operator+(Vector3 rhs) {/* function implementation ...*/}
Vector3 Vector3::operator-(Vector3 rhs) {/* function implementation ...*/}
double Vector3::operator*(Vector3 rhs)  {/* function implementation ...*/}
\end{lstlisting}

\hints{
	\item Der Parameter \texttt{rhs} steht für die rechte Seite (\glqq right-hand-side\grqq{}) des jeweiligen Operators.
	Dadurch, dass der Operator als Member der Klasse deklariert wurde, nimmt die aktuelle Instanz hierbei automatisch die linke Seite der Operation an.
	\item Der Rückgabetyp eines Skalarprodukts (dot product) ist kein \texttt{Vector3} sondern ein Skalar (\texttt{double})!
}

\subsection{Ausgabe}
Überlade den $<<$ Operator zur Ausgabe eines Vektors mit der gewohnten \texttt{std::cout $<<$ ...} Syntax, indem du den folgenden Funktionsprototypen \textbf{außerhalb} der Klassendefinition setzt

\begin{lstlisting}
std::ostream& operator<<(std::ostream &out, Vector3 rhs);
\end{lstlisting}

und innerhalb der Sourcedatei wie folgt implementierst.

\begin{lstlisting}
ostream& operator<<(ostream &out, Vector3 rhs)  {
	out << ... ;
	return out;
}
\end{lstlisting}

Definiere zudem Funktionen die die Werte für die \texttt{private} Attribute \texttt{a}, \texttt{b} und \texttt{c} zurückgeben (Getterfunktionen), anderenfalls wird der Compiler beim Zugriff auf die Attribute folgende Fehlermeldung werfen.
\begin{verbatim}
error: 'double Vector3::a' is private within this context
\end{verbatim}

\hints{
	\item Denke daran, den \texttt{iostream} Header einzubinden.
	\item Diesmal mussten wir die Überladung \textbf{außerhalb} der \texttt{Vektor3}-Klasse definieren, weil auf unser \texttt{Vektor3}-Objekt auf der rechten Seite der Operation steht.
	Als linke Seite wird hierbei ein \texttt{ostream}-Objekt (wie z.B. \texttt{std::cout}) erwartet, um Ausgabeketten \texttt{std::cout} $<<$ \dots $<<$ \dots zu ermöglichen.
	Hierzu muss das Ausgabeobjekt auch zurückgegeben werden, damit das \texttt{ostream}-Objekt aber nicht jedes Mal kopiert wird, wird es als Referenz \textbf{\&} durchgereicht.
	\item Anstatt Getter und Setter für \texttt{private} Attribute zu schreiben, kann man auch einer Klasse oder Funktion vollen Zugriff mit Hilfe des Schlüsselworts \texttt{friend} erlauben.
}


\subsection{Testen}
Teste deine bisher definierten Methoden und Funktionen.
Probiere auch Kombinationen von verschiedenen Operatoren aus und beobachte das Ergebnis.
Schreibe auch eine einfache Funktion, die Vektoren als Parameter nimmt.
Wie du siehst, werden sehr viele \texttt{Vector3}-Objekte erstellt, kopiert und gelöscht.
Dies liegt daran, dass die Objekte immer per Call-By-Value übergeben und dabei kopiert werden.
Wie dies vermieden werden kann, sehen wir im nächsten Teil des Praktikums.



\newpage
\section{Aufzugssimulation}
In dieser Aufgabe soll ein Grundgerüst für den in der Vorlesung vorgestellten Aufzug-Simulator geschaffen werden.
Diese Aufgabe wird in den folgenden Übungen erweitert.
Falls du feststellst, dass dir im Moment die Zeit dafür fehlt, kannst du diese Aufgaben auch nach hinten verschieben und als ausführliche Klausurvorbereitung nutzen.

%Folgendes Klassendiagramm veranschaulicht die Klassenstruktur.
%\includegraphics{figures/Aufzug.png} %TODO replace with header file

\textbf{Hinweis:}
In den folgenden Übungsblättern werden wir den Aufzugsimulator verbessern und erweitern.
Generell gilt, dass diese Aufgaben eher länger sind und das bisher Gelernte festigen sollen.


\subsection{Klasse Person}
Implementiere Klasse \texttt{Person}, die eine Person mit einem gewünschten Ziel Stockwerk darstellt.
Füge allen Konstruktoren und Destrukoren eine Ausgabe auf die Konsole hinzu, um später den Lebenszyklus der Objekte besser nachvollziehen zu können.

\begin{lstlisting}
class Person {
public:
	Person(int destinationFloor);		// create a person with given destination
	Person(const Person& other);		// copy constructor
	~Person();								// destructor
	int getDestinationFloor();			// get destination floor of this person
private:
	int destinationFloor;				// destination floor of this person
};
\end{lstlisting}

\subsection{Klasse Elevator}
Implementiere die Klasse \texttt{Elevator}, die einen Aufzug mit einer beliebigen Anzahl an Personen darstellt.
Passe dabei die verbrauchte Energie bei einer Bewegung sinnvoll an; addiere beispielsweise die Differenz zwischen dem aktuellen und dem Zielstockwerk hinzu.

\begin{lstlisting}
class Elevator {
public:
	Elevator();	// create an elevator at floor 0, no people inside and 0 energy consumed
	int getFloor();					// get number of floor the elevator is currently at
	double getEnergyConsumed();	// get consumed energy
	void moveToFloor(int floor);	// move the elevator to given floor (consumes energy)
	int getNumPeople();				// get number of people in Elevator
	Person getPerson(int i);		// get i-th person in Elevator
	void addPeople(std::vector<Person> people);	// add people to Elevator
	std::vector<Person> removeArrivedPeople();	// remove people which arrived
private:
	int currentFloor;								// current floor number
	std::vector<Person> containedPeople;	// people currently in elevator
	double energyConsumed;						// energy consumed
};
\end{lstlisting}

Um die Klasse \texttt{std::vector} aus der Standardbibliothek zu nutzen musst du noch den Systemheader \texttt{vector} einbinden.
Der Container \texttt{std::vector} kapselt ein Array und stellt eine ähnliche Funktionalität wie Javas \texttt{Vector} Klasse bereit.
Der Typ in spitzen Klammern (\texttt{<Person>} in \texttt{std::vector<Person>}) ist ein Template-Parameter und besagt, dass in dem Container \texttt{Person}-Objekte gespeichert werden sollen.

Folgende Funktion der Klasse \texttt{std::vector} könnten dir von Nutzen sein. Weitere findest du z.B. unter \url{http://www.cplusplus.com/reference/vector/vector/}.

\begin{lstlisting}
size_type size() const;						// get size of the vector
reference at(size_type n);					// get the i-th element of the vector
void push_back(const value_type& val);	// add an element to the vector
void clear();									// remove all elements from the vector
\end{lstlisting}

\hints{
	\item Da \texttt{containedPeople} leer initialisiert werden soll, brauchst du dafür keinen expliziten Aufruf in der Initialisierung.
	\item Um die Leute aussteigen zu lassen, die an ihrem Zielstockwerk angekommen sind, erstelle in der Methode zwei temporäre \texttt{std::vector}-Container \texttt{stay} und \texttt{arrived}.
	Iteriere nun über alle Leute im Aufzug und prüfe, ob das Zielstockwerk der Person mit dem aktuellen Stockwerk des Aufzugs übereinstimmt.
	Wenn ja, lasse die Person aussteigen, indem du sie zu der \texttt{arrived}-Liste mittels \texttt{push\_back()} hinzufügst.
	Andernfalls muss die Person im Aufzug verbleiben (\texttt{stay}-Liste).
	Gib am Ende die arrived-Liste zurück, und ersetze \texttt{containedPeople} durch \texttt{stay}.
}


\subsection{Klasse Floor}
Implementiere die Klasse \texttt{Floor}, die ein Stockwerk mit einer beliebigen Anzahl an wartenden Personen darstellt.

\begin{lstlisting}
class Floor {
public:
	int getNumPeople();							// get the number of people on this floor
	Person getPerson(int i);					// get the i-th person on this floor
	void addWaitingPerson(Person h);			// add a person to this floor
	std::vector<Person> removeAllPeople();	// remove all persons from this floor
private:
	std::vector<Person> containedPeople;	// persons on this floor
};
\end{lstlisting}

\subsection{Klasse Building}
Schreibe eine Klasse \texttt{Building}, die einen Aufzug besitzt der sich zwischen einer definierbaren Menge an Stockwerken bewegt und Personen befördert.

\begin{lstlisting}
class Building {
public:
	Building(int numberOfFloors);	// create a Building with given number of floors
	int getNumOfFloors();			// get number of floors
	Floor& getFloor(int floor);	// get a certain floor
	Elevator& getElevator();		// get the elevator
private:
	std::vector<Floor> floors;		// floors of this building
	Elevator elevator;				// the Elevator
};
\end{lstlisting}


\subsection{Komfortfunktionen}
Implementiere nachfolgende \texttt{public} Funktionen, um die Benutzung des Simulators von außen zu vereinfachen und lange Aufrufketten wie
\begin{lstlisting}
	b.getElevator().addPeople(b.getFloor(b.getElevator().getFloor()).removeAllPeople());
\end{lstlisting}

zu vermeiden (\emph{Law of Demeter}).
Der Simulator sollte nur mit Methoden der Klasse \texttt{Building} kommunizieren.

\begin{lstlisting}
void letPeopleIn();								// let people on current floor into elevator
void moveElevatorToFloor(int i);					// move the elevator to a given floor
void addWaitingPerson(int floor, Person p);	// add a person to a given floor
std::vector<Person> removeArrivedPeople();	// remove people which arrived at their destination from the elevator on the current floor
\end{lstlisting}

\subsection{Beförderungsstrategie}
Teste deine Implementierung.
Erstelle dazu zunächst ein Gebäude und füge einige Personen hinzu.

\begin{lstlisting}
	Building b(3);
	b.addWaitingPerson(0, Person(2)); // person in floor 0 wants to floor 2
	b.addWaitingPerson(1, Person(0)); // person in floor 1 wants to floor 0
	b.addWaitingPerson(2, Person(0)); // person in floor 2 wants to floor 0
\end{lstlisting}

Implementiere nun folgende Beförderungsstrategie.
Diese sehr einfache (und ineffiziente) Strategie fährt alle Stockwerke nacheinander ab, sammelt die Leute ein und befördert sie jeweils zu ihren Zielstockwerken.

\begin{algorithm}[H]
 \SetAlgoLined
 \For{Floor floor \textbf{in} Building}{
   Move \texttt{elevator} to Floor \texttt{floor};\\
   Let all people on \texttt{floor} into \texttt{elevator};\\
   
  \While{elevator has people} {
    Move Elevator to destination Floor of first Person in Elevator; \\
    Remove arrived people; \\
  }
 }
\end{algorithm}

Gib am Ende auch die verbrauchte Energie aus.
Schau dir die Ausgabe genau an und versuche nachzuvollziehen, warum Personen so oft kopiert werden.
Denke daran, dass diese bei einer Übergabe als Argument kopiert werden.



\end{document}
