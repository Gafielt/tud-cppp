\section{Klassen}
Ziel dieser Aufgabe ist es die vorherige Aufgabe objektorientiert zu lösen. Schreibe hierfür manuell eine Klasse, die das aktuelle Zeichen als Attribut enthält und durch Methoden ausgelesen und inkrementiert werden kann.

\hints{
	\item Verwende in dieser Aufgabe noch \textbf{nicht} den Klassengenerator (\textbf{New $\rightarrow$ Class} im Kontext-Menü des Projekts) von Eclipse!
}

\subsection{Definition}
Eine Klasse wird üblicherweise analog zu der vorherigen Aufgabe in Deklaration (Headerdatei) und Implementation (Sourcedatei) aufgeteilt.
Die Struktur der Klasse mit allen Attributen und Funktionsprototypen wird im Header beschrieben, während die Sourcedatei nur die Implementation der Funktionen und Initialisierungen statischer Variablen enthält.
Standardmäßig sind alle Elemente einer Klasse privat.
Im Gegensatz zu Java werden in C++ die Access-Modifier \texttt{public}/\texttt{private}/\texttt{protected} nicht bei jedem Element einzeln sondern blockweise angegeben.

\begin{lstlisting}
class ClassName {
public:
	// public members ...
private:
	// private members ...
};	// semicolon!
\end{lstlisting}

Erzeuge einen Header \texttt{CharGenerator.hpp} und erstelle den Klassenrumpf der \texttt{CharGenerator} Klasse.
Füge der Klasse das \texttt{private} Attribut \texttt{char nextChar} hinzu, in dem das als nächstes auszugebende Zeichen gespeichert wird und einen \texttt{public} Konstruktorprototypen \texttt{CharGenerator()}, der \texttt{nextChar} auf \emph{a} initialiseren soll.
Füge noch eine \texttt{public} Funktionsprototypen \texttt{char generateNextChar()} hinzu, welche das nächste auszugebende Zeichen zurückgeben soll.


\hints{
	\item Ein Konstruktor wird als eine Funktion ohne Rückgabetyp deklariert, die den gleichen Namen wie die Klasse hat, und beliebige Parameter beinhalten kann.
}

\subsection{Implementation}
Wie bei der Verwendung von \texttt{namespace} muss der Scope der Klasse (der Klassenname) in der Sourcedatei vor jeder Elementbezeichnung (Konstruktor, Funktion, \dots) durch zwei Doppelpunkte getrennt angegeben werden.

\begin{lstlisting}
void ClassName::functionName() {
	// function implementation ...
}
\end{lstlisting}

Um Attribute zu initialisieren, wird üblicherweise eine sogenannte Initialisierungsliste im Konstruktor verwendet, da diese vor dem Eintritt in den Konstruktorrumpf aufgerufen wird.
Die Initialisierungsliste wird durch einen Doppelpunkt zwischen der schließenden Klammer der Parameterliste und der geschweiften Klammer des Rumpfes eingeleitet, und bildet eine mit Komma separierte Liste von Attributnamen und ihren Initialisierungsargumenten in Klammern.

\begin{lstlisting}
ClassName::ClassName():
	// initializer list:
	attributeOne(initialValueOne),
	attributeTwo(initialValueTwo)
{
	// constructor body
}
\end{lstlisting}

Erzeuge eine Sourcedatei \texttt{CharGenerator.cpp} für die Implementation der Klasse und binde die \texttt{CharGenerator.hpp} ein.
Implementiere den Konstruktor, indem du \texttt{nextChar} mit \emph{a} in der Initialisierungsliste initialisierst.
Implementiere zudem \texttt{generateNextChar()}, indem du \texttt{nextChar} zurückgibst.

\hints{
	\item Die Reihenfolge der Initialisierungsliste sollte der Deklarationsreihenfolge entsprechen.
	\item Konstanten \textbf{müssen} in der Initialisierungsliste zugewiesen werden, damit diese zur Laufzeit bekannt sind.
}

\subsection{Instanziierung}
Erzeuge wie aus den vorherigen Aufgaben bekannt eine \texttt{main.cpp} mit einer \texttt{main()} Funktion in der du ein \texttt{CharGenerator}-Objekt erzeugst und \texttt{generateNextChar()} mehrfach aufrufst und ausgibst.

\begin{lstlisting}
CharGenerator charGen;
char next = charGen.generateNextChar();
std::cout << next << std::endl;
\end{lstlisting}

Überprüfe das Ergebnis über die Konsole oder den Debugger.

\hints{
	\item Um ein Objekt zu erzeugen, muss in C++ kein \texttt{new} verwendet werden (siehe dazu nächste Vorlesung).
}

\subsection{Default-Parameter}
Damit man nicht immer das Startzeichen angeben muss, kann man sogenannte Default-Parameter angeben, der beim Aufruf weggelassen werden kann.
Hierzu wird dem Parameter im Prototypen (im Header) ein Wert zugewiesen ohne die Implementation zu ändern.

\begin{lstlisting}
class CharGenerator {
public:
	CharGenerator(char initialChar = 'a');
	//...
};
\end{lstlisting}

Erweitere den Konstruktor um einen Parameter \texttt{char initialChar}, welcher defaultmäßig \emph{a} ist und ändere die Initialisierung von \texttt{nextChar}, damit dieser mit dem übergebenen Parameter gestartet wird.

Teste deine Implementation sowohl mit als auch ohne Angabe des Startzeichens.
Um ein Startzeichen anzugeben, lege das Objekt wie folgt an:

\begin{lstlisting}
CharGenerator charGen('x');
\end{lstlisting}

\hints{
	\item Bei der Definition eines Default-Parameters müssen für alle nachfolgenden Parameter ebenfalls Default-Werte angegeben werden, um Mehrdeutigkeiten beim Aufruf zu vermeiden.
}

\subsection{PatternPrinter}
Implementiere folgende Klasse.

\begin{lstlisting}
class PatternPrinter {
private:
	CharGenerator charGen;
	void printNChars(int n);	// print n characters to the console
	int readWidth();				// read width (user input)
public:
	PatternPrinter();
	void printPattern();			// read width and print chars in a pattern
};
\end{lstlisting}

Teste deine Implementation, indem du ein \texttt{PatternPrinter}-Objekt anlegst und \texttt{printPattern()} darauf aufrufst.

\hints{
	\item Ohne eine Initialisierungsliste wird \texttt{charGenerator} mit dem Default-Parameter initialisiert.
	Um ein eigenes Startzeichen anzugeben, muss eine Initialisierungsliste erstellt und \texttt{charGenerator} mit dem entsprechenden Argument initialisiert werden.
}
