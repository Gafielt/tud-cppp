\section{Zeiger und Referenzen Grundlagen}
In dieser Aufgabe sollst du den Umgang mit Zeigern (\emph{Pointer}) und Referenzen erlernen.
Diese erlauben es zum Beispiel Werte zwischen Funktionen auszutauschen ohne eine Kopie der zu übermittelnden Daten zu erzeugen.
Anstelle dessen kann ein (vergleichsweise kleiner) Zeiger auf einen Speichbereich übergeben werden.
Alternativ kann auch eine Referenz auf eine Variable übergeben werden, welche intern ähnlich wie ein Zeiger gehandhabt wird.

\subsection{Experimente}
Experimentiere mit Zeigern, Adressen und Referenzen.
Mache dir eine Skizze, die verdeutlicht, wie Variablen und ihre Speicherabbilder zusammenhängen.
Als Ausgangsbasis kann folgendes Programmfragment dienen.

\begin{lstlisting}
int intVal = 42;
int *pIntVal = &intVal;
cout << "Wert von IntVal " << intVal << endl;
cout << "Wert von &IntVal " << &intVal << endl;
cout << "Wert von pIntVal " << pIntVal << endl;
cout << "Wert von *pIntVal " << *pIntVal << endl;
cout << "Wert von &pIntVal " << &pIntVal << endl;
\end{lstlisting}

\subsection{Bedeutung verstehen}
Versuche die Bedeutung folgender Ausdrücke zu verstehen.
Welche Regelmäßigkeiten stellst du fest?

\begin{lstlisting}
int intVal = 42;
int *pIntVal = &intVal;
*&intVal;
*&pIntVal;
&*pIntVal;
**&pIntVal;
*&*&intVal;
&*&pIntVal;
*&*pIntVal;
\end{lstlisting}

\hints{
	\item Gehe dabei von rechts nach links vor.
}


\subsection{Gültigkeit}
Warum sind folgende Ausdrücke ungültig, sinnlos oder sogar gefährlich?

\begin{minipage}{\textwidth}
\begin{lstlisting}
*intVal;
**pIntVal;
**&*pIntVal;
&*intVal;
&42;
\end{lstlisting}
\end{minipage}

\hints{
	\item Finde heraus, welchen Typ der Ausdruck hätte haben müssen.
	\item Nur tatsächlich angelegte Variablen haben Adressen. Ausdrücke wie a + b oder direkt kodierte Zahlenliterale wie 42 haben keine Adresse-
}

\subsection{Variablentausch}
Schreibe eine Funktion \texttt{swap}, die zwei \texttt{int}-Variablen miteinander vertauscht.
Probiere dabei beide möglichen Übergabevarianten (per Referenz, per Pointer) aus.
Was würde passieren, wenn man die Variablen stattdessen per Wert übergeben würde?

\subsection{Programmanalyse}
Sieh dir folgendes Programm an.

\vbox{%fixes empty page
\begin{lstlisting}
#include <iostream>

void foo(int &i) {
	int i2 = i;
	int &i3 = i;
	
	std::cout << "i = " << i << std::endl;
	std::cout << "i2 = " << i2 << std::endl;
	std::cout << "i3 = " << i3 << std::endl;
	std::cout << "&i = " << &i << std::endl;
	std::cout << "&i2 = " << &i2 << std::endl;
	std::cout << "&i3 = " << &i3 << std::endl;
}

int main() {
	int var = 42;
	std::cout << "&var = " << &var << std::endl;
	foo(var);
}
\end{lstlisting}
}

Welche Adressen werden übereinstimmen, welche werden sich unterscheiden?
Führe das Programm aus.
Hast du diese Ausgabe erwartet?

\subsection{Const Correctness}

In dieser Aufgabe setzt du dich mit der Bedeutung des Schlüsselworts \texttt{const} im Kontext von Pointern auseinander.

Versuche für jede der Variablen im folgenden Code je eine \emph{Verwendung} zu finden, die  
\begin{itemize}
\item gültig ist (= fehlerfrei kompiliert) und
\item nicht gültig ist (= einen Compiler-Fehler wirft).
\end{itemize}


Was ist jeweils der Grund?
Welche Pointer verhalten sich gleich?

\begin{lstlisting}
    int i = 1;    
    int *iP = &i;
    const int *ciP = &i;
    int const *ciP2 = &i;
    int * const icP = &i;    
    const int * const cicP = &i;
\end{lstlisting}

\paragraph{Mehrstufige Pointer}

Versuche nun das Gleiche mit den folgenden mehrstufigen Pointern.

\begin{lstlisting}
    int **iPP = &iP;
    const int * const *cicPP = &iP;
    int ** const iPcP = &iP;
\end{lstlisting}


\PJi{Aufgabe ergänzen / aufsplitten, um auch mit Referenzen auf structs etc. zu experimentieren.
Außerdem Speicherbilder zum Ausfüllen einfügen.}