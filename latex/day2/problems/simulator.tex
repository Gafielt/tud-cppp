\section{Fortsetzung Aufzug}
In dieser Aufgabe erweitern und verbessern wir unseren Aufzugsimulator, sodass das Kopieren von Personen wegfällt.
Dies werden wir erreichen, indem wir nicht direkt mit \texttt{Person}-Objekten oder -rohzeigern sondern mit Smart Pointern arbeiten.
Dadurch müssen wir beim Verschieben von Personen in den Aufzug nur die Smart Pointer kopieren, während die \texttt{Person}-Objekte selbst bestehen bleiben.

Ein weiterer Vorteil ist, dass wir von jeder Person genau ein Exemplar im Speicher halten.
Möchten wir beispielsweise den Namen einer Person ändern, ist dies überall, wo die Person auftaucht sofort und konsistent sichtbar.
Nutzt man überall Kopien von Personen, haben wir keine Kontrolle darüber und wären gezwungen die Klasse \texttt{Person} immutabel zu machen.

\hints{
	\item Stelle auch hier das Projekt auf C++11 ein.
	\item In der nächsten Aufgabe hast du die Möglichkeit, die Performanz der alten und der neuen Implementation zu vergleichen.
	Dazu ist es nötig, dass du jetzt eine Kopie von deinem aktuellen Code machst.
	In Eclipse kannst du ganze Projekte per Copy \& Paste kopieren.
}

\subsection{Refactoring mit Referenzen und \texttt{const}}
Als Erstes verbessern wir die Sauberkeit des vorhandenen Codes mithilfe der bisher kennengelernten Mittel wie Referenzen und \texttt{const}.
Es ist sinnvoll, dass du die Änderungen stückweise im Code durchführst und zwischendurch testest, ob alles noch korrekt funktioniert.

Deklariere dafür sämtliche Getter in \texttt{Building}, \texttt{Elevator}, \texttt{Floor} und \texttt{Person} als \texttt{const}, z.B. \texttt{Building::getFloor()} und \texttt{Elevator::getEnergyConsumed()}.
Passe außerdem die Methode \texttt{Elevator::addPeople()} so an, dass die Liste \texttt{people} nicht mehr als Wert sondern als \texttt{const} Referenz übergeben wird.

\hints{
	\item Um über eine \texttt{const} Liste zu iterieren, verwende \texttt{vector<T>::const\_iterator} anstatt \texttt{vector<T>::iterator} als Iterator-Typ.
}

\subsection{}
Um nicht immer wieder \texttt{std::shared\_ptr<Person>} schreiben zu müssen, definiere ein \texttt{typedef PersonPtr} für diesen Typen.
Binde den Header \texttt{memory} in \texttt{Person.h} ein und definiere den neuen Typen \texttt{PersonPtr} hinter der Klassendefinition von \texttt{Person}:

\begin{lstlisting}
typedef std::shared_ptr<Person> PersonPtr;
\end{lstlisting}

\subsection{Effizientere Listen}
Ändere in der Klasse \texttt{Elevator} alle Vorkommen von \texttt{vector} nach \texttt{list} um, da wir nun eine verkettete Liste verwenden werden, um Personen zu speichern.
Dadurch kann man Personen auch in der Mitte der Liste effizient löschen.

Die \texttt{list}-Klasse enthält keine Methode \texttt{at()}.
Diese ist auch gar nicht nötig:
Wir traversieren die Liste stattdessen mit einem Iterator.
Lösche dazu die Methode \texttt{getPerson()} und füge die folgende Methode hinzu, die eine \texttt{const} Referenz auf die enthaltenen Personen zurückgibt:

\begin{lstlisting}
	/** return a const reference to the list of contained people */
	const std::list<PersonPtr>& getContainedPeople() const;
\end{lstlisting}

Dadurch kann von außen lesend auf die Leute im Aufzug zugegriffen werden.
Ändere außerdem den Inhaltstyp des Containers von \texttt{Person} auf \texttt{PersonPtr}, da wir Smart Pointer auf Personen speichern werden und nicht die Personen direkt.
Passe die Signaturen aller Methoden in \texttt{Elevator} entsprechend an.

\subsection{}
Jetzt müssen wir die Methode \texttt{removeArrivedPeople()} anpassen.
Da wir beliebige Elemente aus \texttt{containedPeople} löschen können, brauchen wir den Umweg über die temporäre Liste \texttt{stay} nicht mehr.

Gehe dazu folgendermaßen vor:
Iteriere mit einen Listeniterator vom Typ \texttt{std::list<PersonPtr>::iterator} über die Personen im Aufzug und prüfe für jede, ob sie an ihrem Zielstockwerk angekommen ist.
Du kannst das Element, auf den der Iterator zeigt, durch den Dereferenzierungsoperator (\texttt{*iter}) holen.
Dieses Element ist selbst ein Smart Pointer.
Deshalb muss der Iterator für den Zugriff auf die Person \texttt{doppelt} dereferenziert werden.
Wenn die Person in ihrem Zielstockwerk angekommen ist, wird sie aus \texttt{containedPeople} gelöscht zu \texttt{arrived} hinzugefügt.
Um ein Element zu löschen, verwende \texttt{containedPeople.erase(iter)}.

\hints{
	\item Der bisherige Iterator ist nach dem Löschen nicht mehr gültig.
	Die Methode \texttt{erase} gibt einen Iterator auf das Element hinter dem gelöschten zurück.
}

Als Grundgerüst kann folgendes Codeschnipsel dienen:

\begin{lstlisting}
	... iter = containedPeople. ...;		// create iterator for containedPeople
	// iterate through all elements
	while (iter != ...) {
		PersonPtr person = ... iter; 		// get person smart pointer at current position
		// check whether person has reached it's destination Floor
		if (...) {
			// erase person pointer from containedPeople
			// no need for ++iter since iter will already point to next item
			... = containedPeople.erase(iter);
			// remember arrived person
			...
		}
		else {
			++iter; // check next person
		}
	}
\end{lstlisting}

\subsection{}
Passe auch die Klassen \texttt{Floor} und \texttt{Building} entsprechend an, sodass nur noch Listen und Smart Pointer auf Personen verwendet werden.

\subsection{}
Passe die Simulation des Aufzugs entsprechend an.
Du wirst auf die erste Person im Aufzug nun auf eine andere Art und Weise zugreifen müssen als vorher.
Benutze die Methode \texttt{getContainedPeople()} des Aufzugs, um an die Liste der Personen zu kommen.
Nun kannst du auf den Inhalt des ersten Elements mittels \texttt{front()} zugreifen.
Vergiss nicht, dass dieser Inhalt ein PersonPtr und nicht die Person direkt ist.
Entweder du dereferenzierst das Element doppelt und verwendest den Operator \texttt{.} oder du nutzt wie üblich bei Pointern den Operator \texttt{->}.

Schau dir die Ausgabe an.
Nun werden Personen nicht mehr kopiert, sondern nur noch gelöscht, sobald sie tatsächlich den Aufzug verlassen haben und kein Zeiger mehr auf sie zeigt.

\subsection{Vergleich der alten und neuen Implementation (optional)}

Es ist natürlich interessant zu erfahren, ob sich der ganze Aufwand des Refactorings gelohnt hat.

\paragraph{Laufzeit}
Eine relativ simple Art der Laufzeitmessung ist es, die verstrichtene Prozessorzeit zu messen.
Der Header \texttt{ctime} stellt hierfür die Funktion \texttt{clock()} zur Verfügung, die einen Zähler vom Typ \texttt{clock\_t} zurückgibt.
Mithilfe der Konstanten \texttt{CLOCKS\_PER\_SEC} kann man aus der Anzahl von Prozessorzyklen die Laufzeit berechnen.

Erzeuge nun ein hinreichend großes Beispiel und teste dessen Laufzeit für die alte und neue Implementation.

\hints{
	\item Es gibt auch ausgefeiltere Möglichkeiten, die Laufzeit zu messen.
	Dazu stellt Boost unter anderem den Header \texttt{boost/chrono.hpp} zur Verfügung.
	Für nähere Informationen siehe \url{http://www.boost.org/doc/libs/1_48_0/doc/html/chrono/users_guide.html}.
}


\paragraph{Speicherverbrauch}
Ein weiteres Argument gegen das Kopieren von Objekten kann der Speicherverbrauch sein.
Das ist in unserem Fall allerdings weniger interessant, da die meisten kopierten Objekte relativ kurz leben und dann wieder gelöscht werden.

Im Gegensatz zur Laufzeit gibt es leider keinen sehr einfachen Weg, den Speicherverbrauch des Programms direkt auszugeben.

Du könntest hierfür kurz vor dem Ende von \texttt{main} die Ausführung pausieren (mittels \texttt{std::cin}) und dir im Task Manager ansehen, wie hoch der Speicherverbrauch des Programms ist -- das ist aber sicherlich nur eine Notlösung.
