\section{Generische Verkettete Liste}
\label{sec:list}
\subsection{}
Schreibe die Klassen \lstinline{List}, \lstinline{ListItem} und \lstinline{ListIterator} aus dem zweiten Praktikumstag so um, dass man den Typen der in der Liste gespeicherten Elemente über ein Template-Parameter angeben kann.

Dazu müssen einige Änderungen gemacht werden.
Zum einen sollte der Inhalt eines Elements beim Erstellen nicht als Wert sondern als \lstinline{const} Referenz übergeben werden.
Zum anderen sollten die Methoden zum Löschen von Elementen \lstinline{void} zurückgeben, und nicht mehr das jeweilige gelöschte Element, weil in diesem Fall eine temporäre Kopie des Elements gemacht werden müsste, ohne dass es der Benutzer beeinflussen kann.
Je nach Elementtyp können solche Kopien problematisch und unerwünscht sein.

\hints{
	\item Arbeite die Klassen nacheinander ab, beginnend bei \lstinline{ListItem}.
	\item Stelle sicher, dass man eine Klasse fehlerfrei kompilieren kann, bevor du zur nächsten übergehst.
	\item Denke daran, dass du auch hier die Implementation in die Header verschieben musst.
}

\subsection{}
Überlade den \lstinline{operator<<}, sodass Listen direkt über ein \lstinline{std::ostream} wie z.B. \lstinline{std::cout} ausgegeben werden können.

\subsection{}
Teste deine Implementation. Probiere auch folgendes aus und beobachte die Ausgabe.

\begin{lstlisting}
	List<List<int> > list; //  ">>" is an operator, so use "> >" for nested templates
	list.appendElement(List<int>());
	list.getFirst().appendElement(1);
	list.getFirst().appendElement(2);
	list.appendElement(List<int>());
	list.getLast().appendElement(3);
	list.appendElement(List<int>());
	list.getLast().appendElement(4);
	list.getLast().appendElement(5);
	
	std::cout << list << std::endl;
\end{lstlisting}
