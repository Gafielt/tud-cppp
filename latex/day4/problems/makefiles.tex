\section{Makefiles}

\LKi{Teilweise Eclipse-spezifisch}

In dieser Übung erkunden wir, wie man Makefile-Projekte in Eclipse aufbaut.
Wir bauen dafür einen Teil unseres Aufzugsimulators nach, um zu sehen, wo die Herausforderungen in echten Projekten mit Makefiles gelöst werden können.

\begin{enumerate}
\item\textbf{Projekt anlegen:}
Öffne \emph{File $\to$ New $\to$ C++ Project} und wähle \textbf{Project type: Makefile project/Empty Project}.
Wähle als \textbf{Toolchain} \textbf{\texttt{Linux GCC}} aus und suche dir einen Projektnamen aus.

Das erzeugte Projekt ist ziemlich leer.
Lege zunächst ein Makefile an über \textbf{File $\to$ New $\to$ Other\dots} und dann \textbf{File} mit Namen \texttt{Makefile}.

Eclipse erwartet, dass das Makefile ein Target mit dem Namen \texttt{all} hat.
Um unser Projekt zu testen, geben wir zunächst eine einfache Meldung auf der Kommandozeile aus.
Lege nun das Target \texttt{all} an und füge den folgenden Befehl an (Vergiss dabei nicht den Tab vor jedem Befehl!):
\begin{lstmake}
all:
	@echo "Running all..."
\end{lstmake}

Wenn du jetzt \emph{Build} aufrufst, sollte in der \emph{Console View} in etwa Folgendes erscheinen:
\begin{verbatim}
18:17:25 **** Incremental Build of configuration Default for project ExerciseMakefileProject ****
make all
Running all...

18:17:26 Build Finished (took 140ms)
\end{verbatim}

\item\textbf{Erster Compilevorgang}

Jetzt ist es an der Zeit, ein Programm mittels \texttt{make} zu kompilieren.
Lege dazu eine C++-Sourcedatei \texttt{main.cpp} mit einer \texttt{main}-Funktion an, die etwas sinnvolles ausgibt.

Entgegen unserer bisherigen Erfahrung musst du nun manuell in \texttt{Makefile} eintragen, dass \texttt{main.cpp} gebaut werden soll.
Ersetze die Dummy-Ausgabe daher durch einen Compiler-Aufruf an \texttt{g++}:
\begin{lstmake}
all:
	g++ -o main.exe main.cpp
\end{lstmake}

Wenn du jetzt \emph{Build} aufrufst, wird dein Programm kompiliert und als \texttt{main.exe} im Projekthauptverzeichnis abgelegt.

\item\textbf{Klasse \emph{Building}:}
Jetzt fügen wir die Klasse \texttt{Building} zu unserem Projekt hinzu, die allerdings nur minimale Funktionalität bietet:

\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}
#pragma once

#include <string>

class Building {
public:
    Building(unsigned int numFloors);
    const std::string toString() const;
private:
    unsigned int numFloors;
};
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{.5\textwidth}
\begin{lstlisting}
#include "Building.h"
#include <sstream>

Building::Building(unsigned int numFloors):
	numFloors(numFloors) {}

const std::string Building::toString() const{
	std::stringstream output;
	output << "A building with " << numFloors;
	output << " floors" << std::endl;
	return output.str();
}
\end{lstlisting}
\end{minipage}

Erzeuge in der \texttt{main}-Funktion eine zweistöckige Instanz von \texttt{Building} und gib diese mittels \texttt{Building::toString} auf der Konsole aus.

Damit das Projekt kompiliert, muss auch \texttt{Building} im Makefile eingetragen werden.
Passe dazu den Compileraufruf an:
\begin{lstmake}
all:
    g++ -o main.exe main.cpp Building.cpp
\end{lstmake}

Wenn du das Projekt gebaut hast und ausführst, sollte auf der Konsole eine Ausgabe deines Gebäudes erscheinen.

\item\textbf{Compiler-Aufrufe auslagern:}
In der Vorlesung haben wir gesehen, dass \emph{make} anhand der Zeitstempel von Dateien dazu in der Lage ist, zu erkennen, wann ein Programmteil neu gebaut werden muss.
Aktuell nutzen wir diese Möglichkeit noch nicht:
Egal ob wir \texttt{main.cpp}, \texttt{Building.cpp} oder \texttt{Building.h} verändert haben, immer wird das gesamte Projekt neu gebaut.
In diesem Schritt zerlegen wir die Abhängigkeiten zu den einzelnen Dateien.

Mache das Target \texttt{all} jetzt abhängig von den Objektdateien \texttt{main.o} und \texttt{Building.o} und erzeuge für jede Objektdatei ein eigenes Ziel, welches diese baut (Das Flag \texttt{-c} sorgt dafür, dass die Sourcedateien nur kompiliert, aber nicht gelinkt werden).
\begin{lstmake}
all: main.o Building.o
	g++ -o main.exe main.o Building.o

main.o: main.cpp
	g++ -c -o main.o main.cpp

Building.o: Building.cpp
	g++ -c -o Building.o Building.cpp
\end{lstmake}

Baue das Projekt nun erneut, du solltest drei Aufrufe von \texttt{g++} sehen:
\begin{verbatim}
make all
g++ -c -o main.o main.cpp
g++ -c -o Building.o Building.cpp
g++ -o main.exe main.o Building.o
\end{verbatim}
Baust du das Projekt nun erneut, so wird nur noch der Linker aufgerufen:
\begin{verbatim}
make all
g++ -o main.exe main.o Building.o
\end{verbatim}

\item\textbf{Linker-Aufruf auslagern}
Wie können wir diesen an sich unnötigen Aufruf ebenfalls noch loswerden?
Eine Lösung ist es, das Target \texttt{all} von \texttt{main.exe} abhängig zu machen und ein neues Ziel \texttt{main.exe} zu definieren:
\begin{lstmake}
all: main.exe

main.exe: main.o Building.o
	g++ -o main.exe main.o Building.o

# ...
\end{lstmake}

Wenn du das Projekt jetzt baust, erhältst du erfreulicherweise die Rückmeldung, dass nichts zu tun ist:
\begin{verbatim}
make all
make: Nothing to be done for `all'.
\end{verbatim}

\item\textbf{Inkrementelles Bauen:}
Wir erproben jetzt, wie sich Veränderungen an einer der drei Dateien auf die Ausführung von \texttt{make} auswirken.
Mache nacheinander kleine Änderungen -- das können auch Kommentare sein -- an den Dateien \texttt{main.cpp}, \texttt{Building.h} und \texttt{Building.cpp} und baue das Projekt nach jeder Änderung.

Dir fällt auf, dass Änderungen an \texttt{Building.h} von \texttt{make} nicht bemerkt werden; die Datei taucht ja nirgendwo explizit im Makefile auf.

Wir sehen uns jetzt an, welche Tragweite dieses Problem haben kann.


\item\textbf{Header als Abhängigkeiten}
Du hast kennengelernt, dass man Implementationen auch \texttt{inline} in einem Header machen kann, zum Beispiel wenn diese klein sind.

Bewege \texttt{toString} nun nach \texttt{Buidling.h}:
\begin{lstlisting}
#include <sstream>
// ...
const std::string toString() const{

    std::stringstream output;
    output << "A building with " << this->numFloors << " floors" << std::endl;
    return output.str();
}
\end{lstlisting}

Baue das Projekt; es kompiliert nicht! Warum? Genau aus dem Grund, dass \texttt{make} das Header-File nicht \glqq kennt\grqq{}.
Jetzt gibt es im Projekt keine Definition von \texttt{toString} wie uns der Linker auch mitteilt:
\begin{verbatim}
main.o:main.cpp:(.text+0x5c): undefined reference to `Building::toString() const'
collect2: ld returned 1 exit status
\end{verbatim}

Das Problem lässt sich lösen, indem wir im Makefile angeben, dass \texttt{main.o} nicht nur abhängig von \texttt{Building.cpp}, sondern auch von \texttt{Building.h} ist:
\begin{lstmake}
# ...
main.o: main.cpp Building.h
	g++ -c -o main.o main.cpp
# ...
\end{lstmake}

Ist das eine schöne Lösung?
Sicherlich nicht, denn ab sofort müssten wir manuell alle Header ins Makefile eintragen, die wir per \texttt{\#include} in eine Sourcedatei einbinden.
Schlimmer noch: Wir müssten über rekursive Includes Bescheid wissen, z.B. wenn \texttt{Building.h} einen anderen veränderlichen Header wie \texttt{Floor.h} einbindet.

Glücklicherweise hilft uns \texttt{g++} bei diesem Problem.

\item\textbf{Header automatisch als Abhängigkeiten deklarieren:}

Wir automatisieren jetzt die Erkennung von Headern als Abhängigkeiten.
Lösche dazu die Abhängigkeit \texttt{Building.h} des Targets \texttt{main.o} und füge in den Compiler-Aufrufen die Parameter \texttt{-MMD -MP} hinzu.
Binde außerdem die Dateien \texttt{Building.d} und \texttt{main.d} ein wie unten dargestellt:
\begin{lstmake}
all: main.exe

main.exe: main.o Building.o
	g++ -o main.exe main.o Building.o

main.o: main.cpp
	g++ -c -MMD -MP -o main.o main.cpp

Building.o: Building.cpp
	g++ -c -MMD -MP -o Building.o Building.cpp

-include Building.d main.d
\end{lstmake}

Um den Effekt dieser Lösung zu sehen, müssen wir alle generierten Dateien löschen (\texttt{main.exe, Building.h, Building.cpp}).
Das anschließende Bauen sollte nun funktionieren.

Der Trick ist, dass \texttt{g++} beim Kompilieren für jede Sourcedatei ein Makefile generiert, das dessen eingebundene Header als Abhängigkeiten enthält (\texttt{main.d, Building.d}).

Wenn du jetzt Änderungen an der \texttt{toString}-Methode durchführst, werden diese anhand des Zeitstempels von \texttt{Building.h} erkannt.




\item\textbf{Target \emph{clean}}

Bisher mussten wir hin und wieder die kompilierten Dateien manuell löschen, wenn wir unser Projekt neu bauen wollten.
Diese Aufgabe lässt sich mittels \texttt{make} ebenfalls automatisieren.

Lege dazu ein neues Target \texttt{clean} ohne Abhängigkeiten an und füge einen entsprechenden Löschbefehl ein:
\begin{lstmake}
clean:
	rm -rf main.o Building.o main.d Building.d main.exe

.PHONY: clean
\end{lstmake}
Das Spezial-Target \texttt{.PHONY} dient dazu, \texttt{make} zu signalisieren, dass \texttt{clean} keine Datei ist, die gebaut werden soll.
Würden wir dieses Target auslassen und eine Datei mit Namen \texttt{clean} erzeugen, würde \texttt{make} die Regel nie ausführen, weil die Datei ja existiert und keine Abhängigkeiten besitzt.
Du solltest \texttt{all} ebenfalls als \texttt{.PHONY} deklarieren.
Probier' es ruhig aus!

Um \texttt{clean} ausführen zu können, öffne die \textbf{Make Target} View über \textbf{Window $\to$ Show View $\to$ Other\dots $\to$ Make/Make Target}.

Klicke rechts auf dein Projekt und wähle \textbf{New\dots}.
Gib in das Feld \textbf{Make Target} \textbf{\emph{clean}} ein und lasse den Rest unverändert.
Unter deinem Projekt wurde nun ein neuer Knoten mit dem Namen \texttt{clean} eingefügt.
Wenn du diesen doppelt anklickst, wird das Target \texttt{clean} ausgeführt.

Lege dir nun auch ein ausführbares Target für \texttt{all} an.





\item\textbf{Generisches Compiler-Target}
Dir ist sicherlich aufgefallen, dass wir zwei Targets haben, die mehr oder weniger identisch sind: \texttt{main.o} und \texttt{Building.o}.

\texttt{make} bietet für solche Situationen generische Regeln an, die mittels Wildcards beschrieben werden.

Ersetze die beiden spezifischen Targets durch folgendes generisches:
\begin{lstmake}
%.o: %.cpp
	g++ -MMD -MP -c $< -o $@
\end{lstmake}
Die etwas kryptischen Ausdrücke \emph{\$<} und \emph{\$@} werden durch die aktuelle Abhängigkeit und Target ersetzt.

Lösche alle automatisch generierten Dateien (\texttt{make clean}) und baue das Projekt neu.





\item\textbf{Variablen in make}

Im Moment sieht unser Makefile in etwa so aus:
\begin{lstmake}
all: main.exe

main.exe: main.o Building.o
	g++ -o main.exe main.o Building.o

%.o: %.cpp
	g++ -MMD -MP -c $< -o $@

-include Building.d main.d

clean:
	rm -rf main.o Building.o main.d Building.d main.exe
	
.PHONY: clean all
\end{lstmake}

Dir ist sicherlich eine andere Form der Redundanz aufgefallen:
Noch immer haben wir die Tatsache, dass es im Moment zwei Sourcedateien gibt, an unterschiedlichen Stellen im Makefile festgelegt.
Wenn wir nun als nächstes die \texttt{Floor}-Klasse entwerfen, müssten wir diese hinzufügen
\begin{itemize}
	\item als Abhängigkeit von \texttt{main.exe},
	\item zum Linker-Aufruf in \texttt{main.exe},
	\item in der \texttt{-include}-Direktive und
	\item im Target \texttt{texttt}, und das gleich doppelt!
\end{itemize}
Das ist natürlich immer noch ziemlich fehleranfällig.

Wir würden also gerne nur an \emph{einer} Stelle definieren, welche Sourcedateien Teil unseres Projektes sind.

Da die Sourcedateien nirgendwo im Makefile auftreten, fangen wir mit den Object-Dateien an.
Lege am Anfang des Makefiles eine Variable mit dem Inhalt '\texttt{main.o Building.o}' und ersetze das Auftreten der beiden Object-Dateien mit dieser Variablen:
\begin{lstmake}
OBJECTS=main.o Building.o

all: main.exe

main.exe: $(OBJECTS)
	g++ -o main.exe $(OBJECTS)
	
# and so on...
\end{lstmake}
\emph{Tipp}: Eclipse bietet für Variablennamen automatische Vervollständigung an (\emph{Ctrl+Space}).

Wiederhole die Prozedur für die Dependency-Dateien ('\texttt{DEPEND=main.d Building.d}') und das ausführbare Programm ('\texttt{BINARY=main.exe}').
Lasse dein Programm zwischendurch immer wieder vollständig neu bauen, um sicherzustellen, dass nichts kaputt geht.

Am Ende sollte dein Makefile in etwa so aussehen:
\begin{lstmake}
BINARY=main.exe
OBJECTS=main.o Building.o
DEPEND=main.d Building.d

all: $(BINARY)

$(BINARY): $(OBJECTS)
	g++ -o $(BINARY) $(OBJECTS)

%.o: %.cpp
	g++ -MMD -MP -c $< -o $@

-include $(DEPEND)

clean:
	rm -rf $(OBJECTS) $(DEPEND) $(BINARY)
	
.PHONY: clean all
\end{lstmake}
%$ for syntax highlighting

Wie wir die verbliebene Redundanz auflösen, sehen wir in der nächsten Teilaufgabe.

\item\textbf{Wildcard-Ausdrücke}

Die beiden Variablen \texttt{OBJECTS} und \texttt{DEPEND} sind strukturell ähnlich -- wieder etwas, das wir loswerden wollen.
Außerdem wäre es doch viel schöner, an einer Stelle die Sourcedateien zu definieren, oder?

Lege dazu eine neue Variable \emph{SOURCES} mit den beiden Sourcedateien an.
Der folgende Snippet zeigt, wie man nun mittels Suffix-Ausdrücken die anderen beiden Variablen erzeugt:
\begin{lstmake}
BINARY	= main.exe
SOURCES	= main.cpp Building.cpp
OBJECTS	= $(patsubst %.cpp, %.o, $(SOURCES))
DEPEND	= $(patsubst %.cpp, %.d, $(SOURCES))
\end{lstmake}

Es geht sogar noch allgemeiner:
Du kannst per regulärem Ausdruck definieren, dass \emph{alle} Sourcedateien im aktuellen Ordner verwendet werden sollen, indem du \emph{SOURCES} wie folgt definierst:

\begin{lstmake}
SOURCES=$(wildcard ./*.cpp)
\end{lstmake}
%$ for syntax highlighting

\end{enumerate}

Das Produkt unserer Bemühungen in dieser Aufgabe ist ein Makefile, das unabhängig davon ist, wie viele Sourcedateien du im aktuellen Verzeichnis hältst und wie sie genau heißen -- wichtig ist nur die Endung \emph{cpp}.

Hier nochmal das vollständige Makefile:
\begin{lstmake}
BINARY	= main.exe
SOURCES	= main.cpp Building.cpp
OBJECTS	= $(patsubst %.cpp, %.o, $(SOURCES))
DEPEND	= $(patsubst %.cpp, %.d, $(SOURCES))

all: $(BINARY)

$(BINARY): $(OBJECTS)
	g++ -o $(BINARY) $(OBJECTS)

%.o: %.cpp
	g++ -MMD -MP -c $< -o $@

-include $(DEPEND)

clean:
	rm -rf $(OBJECTS) $(DEPEND) $(BINARY)

.PHONY: clean
\end{lstmake}
%$ for syntax highlighting

\textbf{Nachwort}:

Dies hier sind nur äußerst wenige der Möglichkeiten, die \texttt{make} bietet\footnote{Für einen besseren Eindruck, sieh dir die Doku an: \url{https://www.gnu.org/software/make/manual/html_node/index.html}}.

In der Praxis existieren Build-Tools, die eine wesentlich besser zu verstehende Beschreibungssprache verwenden und daraus Makefiles generieren.
Beispiele sind \texttt{cmake}\footnote{\url{http://www.cmake.org/cmake/help/cmake_tutorial.html}} oder \texttt{qmake}\footnote{\url{http://qt-project.org/doc/qt-4.8/qmake-tutorial.html}} (Bestandteil von Qt).
