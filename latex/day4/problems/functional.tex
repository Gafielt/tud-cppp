\section{Funktionales Programmieren}

In dieser Aufgabe werden wir uns mit Funktionen aus der funktionalen Programmierung beschäftigen.
Diese sind \lstinline{map}, \lstinline{filter} und \lstinline{reduce}. \\

Der Ablauf ist wie folgt:
\begin{itemize}
    \item Wir werden im folgenden erst einmal einzeln auf die Funktionen eingehen.
    \item Danach wird es eure Aufgabe sein, diese Funktionen nachzuprogrammieren.
    \item Da wir diese Funktionen danach verwenden wollen, werden wir dafür passende Funktionen programmieren.
	\item Im Folgenden werden wir diese Funktionen als \emph{Funktoren} implementieren.
	\item Dann werden wir noch Templates mit einbauen, damit Funktionen und Funktoren verwendet werden können.
			Aber dazu später mehr.
\end{itemize}

\subsection{Erklärung \lstinline{map}, \lstinline{filter} und \lstinline{reduce}}

Arbeitet man auf iterierbaren Sequenzen, ist dies fast immer mit Schleifen über die Sequenz verbunden.
Die drei genannten Funktionen vereinfachen uns hierbei dir Arbeit.
Hierzu ein Beispiel.

Haben wir ein Vektor von Integern und wir wollen jedes Element quadrieren, endet dies meist in dem folgenden Programmcode:

\begin{lstlisting}
std::vector<int> numbers = { 1, 2, 3, 4, 5 };

for (std::vector<int>::iterator it = numbers.begin(); it != numbers.end(); ++it) {
    *it = square(*it); // squaring element pointed to by it
}

// numbers now [ 1, 4, 9, 16, 25 ]
\end{lstlisting}

Die Idee von der Funktion \lstinline{map} ist es genau dies zu vereinfachen.
Sie bekommt den Startiterator, der Sequenz und den Enditerator.
Außerdem bekommt sie einen Funktionspointer als Parameter und ruft diese Funktion auf jedes Element der iterierbaren Sequenz auf.

\begin{lstlisting}
std::vector<int> numbers = { 1, 2, 3, 4, 5 };

map(numbers, square);

// numbers now [ 1, 4, 9, 16, 25 ]
\end{lstlisting}

\lstinline{filter} funktioniert analog, indem sie einen Funktionspointer auf eine Funktion erhält, die ein Listenelementtyp erhält und ein \lstinline{bool} zurück gibt.
Auf alle Elemente wird diese Funktion aufgerufen und alle Elemente, für die die Funktion \lstinline{true} zurückgibt, bleiben in der Liste. Der Rest wird entfernt. \\

\begin{lstlisting}
std::vector<int> numbers = { 1, 2, 3, 4, 5 };

filter(numbers, isOdd);

// numbers now [ 1, 3, 5 ]
\end{lstlisting}

Und auch \lstinline{reduce} hat eine ähnliche Verwendung.
Es schrumpft eine Sequenze zu einem Element zusammen.
Hierbei wir aber ein zusätzlicher Parameter, nämlich einen Startwert mitgegeben.
Hier ein Beispiel, bei dem die Summe über die Elemente in \lstinline{numbers} gebildet wird.

\begin{lstlisting}
std::vector<int> numbers = { 1, 2, 3, 4, 5 };

std::cout << reduce(numbers, 0, sum) << std::endl; // 15
\end{lstlisting}

\subsection{Programmieren der Funktionen}

Nun werden wird es deine Aufgabe sein, die drei Funktionen nachzuprogrammieren.
Hierbei geht es erstmal darum ein funktionierendes Gerüst der Methoden zu erstellen, anstatt perfekt generische Algorithmen zu erhalten.
Darum wird sich im Laufe der Aufgabe gekümmert.

\subsubsection{\lstinline{map}}

Bitte schreibt eine Funktion \lstinline{map} die folgendermaßen aussieht.

\begin{lstlisting}
template<typename SeqT>
void map(SeqT &seq, int(*func)(int i));
\end{lstlisting}

Hierbei ist der letzte Parameter der Funktionspointer.
Die Klammern um \lstinline{*func} sind deshalb notwendig, damit die Sichtbarkeit sichergestellt ist und der Kompiler den übergebenen Parameter als Funktionspointer einer Funktion mit Rückgabewert \lstinline{int} interpretiert und nicht als Funktion mit Rückgabewert \lstinline{int *}\footnote{Welche folgende Signature hätte: \lstinline{int *(*func)(int i)}}.
Diese Funktion hat zusätzlich noch einen Integer \lstinline{i} als Paramenter.

\subsubsection{\lstinline{filter}}

Die von dir zu schreibende Funktion \lstinline{filter} soll der folgenden Signatur folgen.

\begin{lstlisting}
template<typename SeqT>
void filter(SeqT seq, bool(*p)(int i));
\end{lstlisting}

\subsubsection{\lstinline{reduce}}

Erstelle eine Funktion \lstinline{reduce}, die der folgenden Signatur folgt.

\begin{lstlisting}
template<typename SeqT, typename RetT>
RetT reduce(SeqT &seq, RetT initialVal, RetT(*func)(RetT &i, int j));
\end{lstlisting}

Hierbei muss ein passender initialer Wert übergeben werden, der mit dem Rückgabewert und dem ersten Argument der übergebenen Funktion zusammenpasst.

\subsection{Passende Funktionen}
Implementiere in dieser Aufgabe drei Funktionen, die den Anforderunger der jeweiligen Signaturen der Funktionspointer in den Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} folgt.

Ihr könnt euch dabei gerne eigene Funktionen ausdenken oder euch an die Funktionen in den Beispielen halten.
