\section{Funktionales Programmieren}

In dieser Aufgabe werden wir uns mit Funktionen aus der funktionalen Programmierung beschäftigen.
Diese sind \lstinline{map}, \lstinline{filter} und \lstinline{reduce}. \\

Der Ablauf ist wie folgt:
\begin{itemize}
    \item In \Cref{sec:map-filter-reduce-intro} werden wir erst einmal auf die Arbeitsweise der zu implementierenden Funktionen eingehen.
    \item In \Cref{sec:map-filter-reduce-basic-impl} wirst du diese Funktionen nachprogrammieren.
    \item In \Cref{sec:functional_impl_func} wir diese Funktionen danach verwenden wollen, werden wir dafür passende Funktionen programmieren.
	\item Im Folgenden werden wir diese Funktionen als \emph{Funktoren} implementieren.
	\item Dann werden wir noch Templates mit einbauen, damit Funktionen und Funktoren verwendet werden können.
			Aber dazu später mehr.
\end{itemize}

\subsection{Erklärung \lstinline{map}, \lstinline{filter} und \lstinline{reduce}}\label{sec:map-filter-reduce-intro}

Arbeitet man auf iterierbaren Sequenzen, ist dies fast immer mit Schleifen über die Sequenz verbunden.
Die drei Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} vereinfachen uns hierbei dir Arbeit.
Hierzu ein Beispiel.
Haben wir ein Vektor von Integern und wir wollen jedes Element quadrieren, endet dies meist in dem folgenden Programmcode:

\lstinputlisting{problems/listings/functional_intro_example.cpp}

Die Idee von der Funktion \lstinline{map} ist es, genau dies zu vereinfachen.
Sie erhält die Start- und Enditeratoren der Sequenz und einen Funktionszeiger als Parameter und ruft diese Funktion auf jedes Element der iterierbaren Sequenz auf.

\lstinputlisting{problems/listings/functional_map_example.cpp}

\lstinline{filter} funktioniert analog, indem sie einen Funktionspointer auf eine Funktion erhält, die ein Listenelementtyp erhält und ein \lstinline{bool} zurück gibt.
Auf alle Elemente wird diese Funktion aufgerufen und alle Elemente, für die die Funktion \lstinline{true} zurückgibt, bleiben in der Liste. Der Rest wird entfernt. \\

\lstinputlisting{problems/listings/functional_filter_example.cpp}

Und auch \lstinline{reduce} hat eine ähnliche Verwendung.
Es schrumpft eine Sequenze zu einem Element zusammen.
Hierbei wir aber ein zusätzlicher Parameter, nämlich einen Startwert mitgegeben.
Hier ein Beispiel, bei dem die Summe über die Elemente in \lstinline{numbers} gebildet wird.

\lstinputlisting{problems/listings/functional_reduce_example.cpp}

\subsection{Programmieren der Funktionen}
\label{sec:map-filter-reduce-basic-impl}

Nun werden wird es deine Aufgabe sein, die drei Funktionen nachzuprogrammieren.
Hierbei geht es erstmal darum ein funktionierendes Gerüst der Methoden zu erstellen, anstatt perfekt generische Algorithmen zu erhalten.
Darum wird sich im Laufe der Aufgabe gekümmert.

\subsubsection{\lstinline{map}}

Bitte schreibt eine Funktion \lstinline{map} die folgendermaßen aussieht.

\lstinputlisting{problems/listings/functional_map_sig.cpp}

Hierbei ist der letzte Parameter der Funktionspointer.
Die Klammern um \lstinline{*func} sind deshalb notwendig, damit die Sichtbarkeit sichergestellt ist und der Kompiler den übergebenen Parameter als Funktionspointer einer Funktion mit Rückgabewert \lstinline{int} interpretiert und nicht als Funktion mit Rückgabewert \lstinline{int *}\footnote{Welche folgende Signature hätte: \lstinline{int *(*func)(int i)}}.
Diese Funktion hat zusätzlich noch einen Integer \lstinline{i} als Paramenter.

\subsubsection{\lstinline{filter}}

Die von dir zu schreibende Funktion \lstinline{filter} soll der folgenden Signatur folgen.

\lstinputlisting{problems/listings/functional_filter_sig.cpp}

\subsubsection{\lstinline{reduce}}

Erstelle eine Funktion \lstinline{reduce}, die der folgenden Signatur folgt.

\lstinputlisting{problems/listings/functional_reduce_sig.cpp}

Hierbei muss ein passender initialer Wert übergeben werden, der mit dem Rückgabewert und dem ersten Argument der übergebenen Funktion zusammenpasst.

\subsection{Passende Funktionen implementieren}
\label{sec:functional_impl_func}
Implementiere in dieser Aufgabe drei Funktionen, die den Anforderunger der jeweiligen Signaturen der Funktionspointer in den Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} folgt.
Ihr könnt euch dabei gerne eigene Funktionen ausdenken oder euch an die Funktionen in den Beispielen halten. \\

Teste anschließend deine Implementierung, indem du die Funktionen nur anhand ihres Namens übergibst.

\subsection{Funktoren}
Es gibt noch die Möglichkeit Funktionen in einem Funktionsobjekt (\emph{Funktor}) zu schachteln.
Dabei überlad man den Operator \lstinline{operator()}, welcher eine bestimmte Funktion hat. \\

Schaut man sich in unserem Beispiel die Funktion \lstinline{square}, welche folgende Signatur hat \lstinline{int square(int i);} würde der Funktor wie folgt aussehen.

\lstinputlisting{problems/listings/functional_functor_square.cpp}

Die Funktion \lstinline{map} würde wie folgt umgeschrieben werden müssen.

\lstinputlisting{problems/listings/functional_functor_map.cpp}

Schreibt eure Funktionen aus \ref{sec:functional_impl_func} als Funktoren und passt eure Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} dementsprechend an.
Anschließend stellt sicher, dass eure Implementierung noch funktioniert.

\subsection{Verwendung von Templates}
Die zurzeitige Implementierung funktioniert entweder mit Funktoren einer bestimmten Klasse oder mit Funktionszeigern, die einem bestimmten Typen angehören, der durch die Signatur der Funktion gebunden ist.
Das ist nicht immer das gewünschte Ergebnis.
Um das Problem zu lösen kann man den Übergabetypen durch ein Template setzen, wodurch der Typ der Übergabe nicht mehr relevant ist.
Dadurch ist die Parameteranzahl und die Typen der Parameter losgelöst und jede beliebige Funktion kann übergeben werden.
Innerhalb der Funktion muss nur darauf geachtet werden, dass dem Funktionspointer/Funktor die richtige Variable übergeben wird. \\

Implementiert in euren Funktionen einen Templatetypen für die Funktionspointer/Funktoren und testet euren Code sowohl mit Funktoren und Funktionen.
