\section{Funktionales Programmieren \experimental}

\experimentaltextbox

In dieser Aufgabe werden Funktionen aus der funktionalen Programmierung vorgestellt.
Diese sind \lstinline{map}, \lstinline{filter} und \lstinline{reduce}. \\

Der Ablauf ist wie folgt:
\begin{itemize}
    \item In Teilaufgabe \ref{sec:map-filter-reduce-intro} werden erst einmal die Funktionsweisen der zu implementierenden Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} vorgestellt.
	\item In Teilaufgabe \ref{sec:map-filter-reduce-basic-impl} wirst du diese Funktionen implementieren und Hilfsfunktionen, welche dann verwendet werden können, implementieren.
	\item In Teilaufgabe \ref{sec:functional_functor} wirst du deine Hilfsfunktionen als \emph{Funktoren} implementieren und \lstinline{map}, \lstinline{filter} und \lstinline{reduce} entsprechend anpassen.
	\item Daraufhin werden Templates einbauen, damit Funktionen und Funktoren verwendet werden können. Dies wird in Teilaufgabe \ref{sec:functional_template} passieren.
	\item In Teilaufgabe \ref{sec:functional_method} werden außerdem noch Methodenzeiger vorgestellt.
\end{itemize}

\subsection{Erklärung \lstinline{map}, \lstinline{filter} und \lstinline{reduce}}\label{sec:map-filter-reduce-intro}

Arbeitet man auf iterierbaren Sequenzen, ist dies fast immer mit Schleifen über die Sequenz verbunden.
Die drei Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} vereinfachen uns hierbei dir Arbeit.
Hierzu ein Beispiel.
Haben wir ein Vektor von Doubles und wollen jedes Element quadrieren, endet dies meist in dem folgenden Programmcode:

\lstinputlisting{problems/listings/functional_intro_example.cpp}

Die Idee von der Funktion \lstinline{map} ist es, genau dies zu vereinfachen.
Sie erhält die Start- und Enditeratoren der Sequenz, einen Iterator, der auf eine Sequenz zeigt in dem die veränderten Elemente gespeichert werden und einen Funktionszeiger als Parameter und ruft diese Funktion auf jedes Element der iterierbaren Sequenz auf.

\lstinputlisting{problems/listings/functional_map_example.cpp}

\lstinline{filter} funktioniert analog, indem sie einen Funktionszeiger auf eine Funktion erhält, die ein Listenelementtyp erhält und ein \lstinline{bool} zurück gibt.
Auf alle Elemente wird diese Funktion aufgerufen und alle Elemente, für die die Funktion \lstinline{true} zurückgibt, werden in die Ausgabesequenz kopiert. Der Rest wird entfernt. \\

\lstinputlisting{problems/listings/functional_filter_example.cpp}

Und auch \lstinline{reduce} hat eine ähnliche Verwendung.
Es schrumpft eine Sequenze zu einem Element zusammen.
Hierbei wird der Ausgabeiterator gegen einen Startwert ausgetauscht.
Hier ein Beispiel, bei dem die Summe über die Elemente in \lstinline{numbers} gebildet wird.

\lstinputlisting{problems/listings/functional_reduce_example.cpp}

\subsection{Programmieren der Funktionen}
\label{sec:map-filter-reduce-basic-impl}

Du wirst die drei Funktionen nachprogrammieren.
Hierbei geht es erstmal darum ein funktionierendes Gerüst der Methoden zu erstellen, anstatt perfekt generische Algorithmen zu erhalten.
Darum wird sich im Laufe der Aufgabe gekümmert.

\subsubsection{\lstinline{map}}

Schreibe eine Funktion \lstinline{map} die folgende Signature besitzt.

\lstinputlisting{problems/listings/functional_map_sig.cpp}

Hierbei ist der letzte Parameter der Funktionszeiger.
Die Klammern um \lstinline{*func} sind deshalb notwendig, damit die Sichtbarkeit sichergestellt ist und der Kompiler den übergebenen Parameter als Funktionszeiger einer Funktion mit Rückgabewert \lstinline{double} interpretiert und nicht als Funktion mit Rückgabewert \lstinline{double *}\footnote{Welche folgende Signature hätte: \lstinline{double *(*func)(double d)}}.
Diese Funktion hat zusätzlich noch einen Double \lstinline{d} als Paramenter.

\subsubsection{\lstinline{filter}}

Die von dir zu schreibende Funktion \lstinline{filter} soll der folgenden Signatur folgen.

\lstinputlisting{problems/listings/functional_filter_sig.cpp}

\subsubsection{\lstinline{reduce}}

Erstelle eine Funktion \lstinline{reduce}, die der folgenden Signatur folgt.

\lstinputlisting{problems/listings/functional_reduce_sig.cpp}

Hierbei muss ein passender initialer Wert übergeben werden, der mit dem Rückgabewert und dem ersten Argument der übergebenen Funktion zusammenpasst.

\subsubsection{Passende Hilfsfunktionen implementieren}
Implementiere in dieser Aufgabe drei Hilfsfunktionen, die den Anforderunger der jeweiligen Signaturen der Funktionszeiger in den Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} folgt.
Du kannst dir dabei gerne eigene Funktionen ausdenken oder dich an die Funktionen in den Beispielen halten. \\

Teste anschließend deine Implementierung, indem du die Funktionen nur anhand ihres Namens übergibst.

\subsection{Funktoren}
\label{sec:functional_functor}
Es gibt noch die Möglichkeit Funktionen in einem Funktionsobjekt (\emph{Funktor}) zu schachteln.
Dabei überläd man den Operator \lstinline{operator()}, welcher eine bestimmte Funktion ausführt. \\

Schaut man sich in unserem Beispiel die Funktion \lstinline{square} an, welche folgende Signatur hat \lstinline{double square(double i);} würde der Funktor wie folgt aussehen.

\lstinputlisting{problems/listings/functional_functor_square.cpp}

Die Funktion \lstinline{map} würde wie folgt umgeschrieben werden müssen.

\lstinputlisting{problems/listings/functional_functor_map.cpp}

Schreibe dein Hilfsfunktionen als Funktoren und füge eine neue Implementierung für deine Funktionen \lstinline{map}, \lstinline{filter} und \lstinline{reduce} hinzu, die mit den Funktoren kompatibel ist.
Anschließend stelle sicher, dass deine Implementierung noch funktioniert.

\subsection{Verwendung von Templates}
\label{sec:functional_template}
Die zurzeitige Implementierung funktioniert entweder mit Funktoren einer bestimmten Klasse oder mit Funktionszeigern, die einem bestimmten Typen angehören, der durch die Signatur der Funktion gebunden ist.
Das ist nicht immer das gewünschte Ergebnis.
Um das Problem zu lösen kann man den Übergabetypen durch ein Template setzen, wodurch der Typ der Übergabe nicht mehr relevant ist.
Dadurch ist die Parameteranzahl und die Typen der Parameter losgelöst und jede beliebige Funktion kann übergeben werden.
Innerhalb der Funktion muss nur darauf geachtet werden, dass dem Funktionszeiger/Funktor die richtige Variable übergeben wird. \\

Implementiere in deinen Funktionen einen weiteren Templatetypen \lstinline{template <typename InIt, typename OutIt, typename ...>} und verwende diesen statt der zur Zeit hardgecodeten Signatur für die übergebene Funktion/den übergebenen Funktor.
Teste deine Implementierung anschließend sowohl mit Funktoren, als auch mit Funktionen.

\subsection{Methodenzeiger}
\label{sec:functional_method}
Es gibt auch die Möglichkeit Methoden\footnote{Hier ist eine einfache Erklärung zu dem Unterschied von Funktion und Methode zu finden \url{http://stackoverflow.com/a/155655}} via Zeigern auszuführen.
Hierzu muss man zusätzlich zu der Funktion noch ein Objekt übergeben, auf welches die Funktion ausgeführt wird. \\

In unserem Beispiel von \lstinline{Square} fügen wir noch eine weitere Methode \lstinline{inverse} hinzu, welche das Inverse der Quadrierung, die Wurzeloperation, ausführt. \\

Unsere Klasse Square verändert sich dementsprechend zu

\lstinputlisting{problems/listings/functional_method_square.cpp}

und unser \lstinline{map} zu 

\lstinputlisting{problems/listings/functional_method_map.cpp}

Deine Aufgabe ist es nun eine neue Implementierung von \lstinline{map} hinzuzufügen, deinen für Map geschriebenen Funktor eine weitere Methode hinzuzufügen und anschließend deine Implementierung mit allen implementierten Methoden zu testen.
