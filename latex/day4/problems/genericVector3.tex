\section{Generische Vektor-Implementation}
Erinnere dich an die Klasse \lstinline{Vector3} aus dem ersten Praktikumstag. Diese hat den Datentyp \lstinline{double} für die einzelnen Komponenten verwendet. Schreibe die Klasse so um, dass der Datentyp der Komponenten durch einen Template-Parameter angegeben werden kann.
Füge dafür der Klasse \lstinline{Vector3} einen Template-Parameter hinzu und ersetze jedes Aufkommen von \lstinline{double} mit dem Template-Parameter.
Vergiss nicht, die Implementation in den Header zu verschieben, da der Compiler die Definition einer Klasse kennen muss, um beim Einsetzen des Template-Parameters den richtigen Code zu generieren.

Verbessere außerdem die Effizienz und Sauberkeit der \lstinline{Vector3}-Klasse, in dem du die Parameterübergabe in den entsprechenden Methoden auf \lstinline{const} Referenzen umstellst und alle Getter als \lstinline{const} deklarierst.

Du weißt bereits, dass alle \lstinline{template}-Funktionen und -Methoden im Header enthalten sein müssen.
Um den Code trotzdem zu strukturieren, hat es sich eingebürgert, dass man die Klassendefinition in der \filename{hpp}-Datei hält, ohne die Methoden zu implementieren.
Im Anschluss wird eine \filename{tpp}-Datei inkludiert, die die Implementierung der Methoden und Funktionen enthält.
    
Der Aufbau wäre also in etwas wie folgt:
\begin{lstlisting}
template<typename T>
class Vector3 {
  // method declarations only
};

// function declarations only

#include "Vector3.tpp" // contains method and function definitions
\end{lstlisting}
\LKi{Eclipse-spezifisch}
\hints {
\item Dateien mit der Endung \filename{tpp} werden von Eclipse CDT eventuell nicht als C++-Code erkannt.
Um das zu ändern, muss du die Endung \filename{*.tpp} an folgender Stelle registrieren: \textbf{Window -> Preferences -> General / Content Types -> Text / C Source File / C++ Source File / C++ Header File}.
    
}
