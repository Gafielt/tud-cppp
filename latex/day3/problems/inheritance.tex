\section{Vererbung und Polymorphie}\label{sec:inheritance}
In dieser Aufgabe sollst du Konzepte der Vererbung und Polymorphie unter Verwendung abstraker Funktionen erlernen.

\subsection{Klasse \texttt{Person}}
Implementiere eine Klasse \texttt{Person}, die eine Person mit einem Namen darstellt.
Füge allen Konstruktoren und Destrukoren eine Ausgabe auf die Konsole hinzu, um später den Lebenszyklus der Objekte besser nachvollziehen zu können.

\begin{lstlisting}
class Person {
public:
	Person(const std::string &name);		// initialize the name of the person
	~Person();									// destructor
	std::string getInfo() const;			// get the name of the person
protected:
	std::string name;							// the name of the person
};
\end{lstlisting}

\hints{
	\item Verwende \texttt{\#include <string>} um \texttt{std::string} zu verwenden.
	\item Um ein String-Literal an eine \texttt{std::string} Variable anzuhängen, musst du aus dem String-Literal zuerst ein \texttt{std::string}-Objekt machen: \texttt{std::string text = std::string("Name: " ) + name;}.
}

\subsection{Klasse \texttt{Student}}
Implementiere eine Klasse \texttt{Student}, die von \texttt{Person} erbt (\texttt{public}) und einen Studenten mit einer Matrikelnummer (ebenfalls \texttt{std::string}) modelliert.
Rufe in der Initialisierungsliste den entsprechenden Konstruktor der Elternklasse \texttt{Person} mittels \texttt{Person(name)} auf.
Füge allen Konstruktoren und Destrukoren eine Ausgabe auf die Konsole hinzu, um später den Lebenszyklus der Objekte besser nachvollziehen zu können.

\begin{lstlisting}
class Student: public Person {	// public inheritance
public:
	Student(const std::string &name, const std::string &studentID); // init name and ID
	~Student();							// destructor
	std::string getInfo() const;	// override Person::getInfo() - get name and studentID
private:
	std::string studentID;			// the student ID of the student
};
\end{lstlisting}

\hints{
	\item Erst ab C++11 gibt es die Möglichkeit mit dem Schlüsselwort \texttt{override} zu deklarieren, dass eine Funktion eine andere (virtuelle) überschreibt (vergleichbar mit der Annotation \texttt{@Override} in Java). Trotzdem zeigt dir Eclipse mit einem kleinen aufwärts zeigenden Dreieck links neben den Zeilennummern an, ob du eine Methode überschreibst oder nicht.
	\item Du kannst bei Bedarf die \texttt{getInfo()}-Implementation der Elternklasse \texttt{Person} von \texttt{Student} aus mittels \texttt{Person::getInfo()} aufrufen.
}

\subsection{Test}
Erstelle nun in \texttt{main()} je eine Person und einen Studenten und gib deren Daten auf der Konsole aus.
Vergewissere dich, dass bei \texttt{Student} auch die Matrikelnummer ausgegeben wird.
Schau dir auch die Ausgaben der Konstruktoren und Destruktoren an, und versuche, diese nachzuvollziehen.

Implementiere dann folgende Funktion und teste deine Implementation erneut, indem du \texttt{printPersonInfo()} mit beiden Personentypen aufrufst.

\begin{lstlisting}
void printPersonInfo(const Person *person);		// print person information on console
\end{lstlisting}

\hints{
	\item Dadurch dass \texttt{Person} als \texttt{const} Zeiger übergeben wird, können auch Unterklassen von \texttt{Person}, wie z.B. \texttt{Student}, übergeben werden. 
}


\subsection{Dynamic Dispatch bei \texttt{printPersonInfo}}
Du merkst, dass \texttt{printPersonInfo()} unabhängig von übergebenem Personentyp immer nur den Namen der Person ausgibt, aber nicht die Matrikelnummer.
Der Grund dafür ist, dass \texttt{getInfo()} nicht als \texttt{virtual} deklariert wurde und deshalb auch kein dynamischer Dispatch der Methode stattfindet.
Deklariere daher \texttt{getInfo()} in beiden Klassen als \texttt{virtual}.

Teste deine Implementation erneut und vergewissere dich, dass nun immer die richtige Methode aufgerufen wird.

\hints{
	\item Möchte man Methoden einer Basisklasse überschreiben, \textbf{muss} \texttt{virtual} in der Basisklasse gesetzt werden.
	In den abgeleiteten Klassen kann \texttt{virtual} weggelassen werden, es wird dann vom Compiler ergänzt.
	Es ist aber hilfreich, auch dort der Lesbarkeit halber das Schlüsselwort zu verwenden.
}

\subsection{Virtueller Destruktor}
Lege einen Studenten mit \texttt{new} dynamisch auf dem Heap an und speichere die Adresse in einem Zeiger auf eine \texttt{Person}.
Lösche die Person anschließend mit \texttt{delete}.

\begin{lstlisting}
	Person *pTim = new Student("Tim", "321654");
	delete pTim;
\end{lstlisting}

Analysiere die Konsolenausgabe.
Es wird nur der Destruktor von \texttt{Person} aufgerufen, obwohl es sich um ein Objekt vom Typ \texttt{Student} handelt.
Auch hier liegt es daran, dass kein dynamischer Dispatch bei der Zerstörung erfolgt.
Deklariere deshalb in beiden Klassen den Destruktor als \textbf{virtual} und teste die Korrektheit der Destruktoraufrufe.

\hints{
	\item Faustregel: Besitzt eine Klasse mindestens eine virtuelle Funktion, so sollte auch der Destruktor virtuell sein.
}
